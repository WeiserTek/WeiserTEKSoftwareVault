//+------------------------------------------------------------------+
//| PhoenixTrendTraderv0.014 EA
//|
//|    Generated by StrategyQuant EA Wizard version 2.0.1
//|    Generated at Sat Mar 30 23:02:00 EDT 2019
//+------------------------------------------------------------------+
#property copyright "StrategyQuant.com"
#property link      "http://www.StrategyQuant.com"

#define PATTERN_DOJI 1
#define PATTERN_HAMMER 2
#define PATTERN_SHOOTING_STAR 3
#define PATTERN_DARK_CLOUD 4
#define PATTERN_PIERCING_LINE 5
#define PATTERN_BEARISH_ENGULFING 6
#define PATTERN_BULLISH_ENGULFING 7
#define PATTERN_BEARISH_HARAMI 8
#define PATTERN_BULLISH_HARAMI 9
#define PATTERN_BEARISH_HARAMI_CROSS 10
#define PATTERN_BULLISH_HARAMI_CROSS 11



//+------------------------------------------------------------------+
// -- Variables
//+------------------------------------------------------------------+
extern string Var7 = ">>>>>>>>>>> TRADING BLOCKS <<<<<<<<<";
extern string Var29 = ">>>>>>>>>> DEBUG SECTION >>>>>>>>>>>";
extern bool Debug_ClusterObjectDebugFlagOn = false;
extern bool Debug_PivotBarDebugFlagOn = false;
extern bool Debug_TriangleBreakoutDebugFlagOn = false;
extern bool Debug_BreakoutLineDebugFlagOn = false;
extern bool Debug_BreakoutLinePriceDebugFlagOn = false;
extern bool Debug_ThreeEMATrendDirectionFlagOn = false;
extern bool Debug_CurrentTriangleBreakoutDirectionFlagOn = false;
extern bool Debug_WaveBreakOrderEntryManagerFlagOn = true;
extern bool Debug_CurrentCandleColorCorrectFlagOn = false;
extern bool Debug_PreviousCandleColorCorrectFlagOn = false;
extern bool Debug_CurrentOpenPastPreviousOpenFlagOn = false;
extern bool Debug_TrianglePointOneNotviolatedFlagOn = false;
extern bool Debug_CurrentTriangleIndexNumberFlagOn = false;
extern string Var32 = ">>>>>>>>>> ROBOT CONTROLS >>>>>>>";
extern bool ThreeEMATrendDirectionEnabled = false;
extern bool BreakoutPriceFlagEnabled = true;
extern bool TriangleBreakoutDirectionEnabled = true;
extern bool CurrentOpenPastPreviousOpenFlagEnabled = true;
extern bool CurrentCandleColorCorrectFlagEnabled = false;
extern bool PreviousCandleColorCorrectFlagEnabled = false;
extern bool TrianglePointOneNotVioloatedFlagEnabled = false;
extern bool PivotLineTypeEnabled = false;
extern string Var20 = "-------- WaveBreak -------------------------------";
extern int Input_WaveBreak_Timeframe = 1440;
extern int Input_WaveBreakPivotPointsToTrack = 15;
int Output_WaveBreak_Point1Bar = 0;
int Output_WaveBreak_Point2Bar = 0;
int Output_WaveBreak_Point3Bar = 0;
int Output_WaveBreak_TrendDirection = 0;
bool Initialized_WaveBreakFlagOn = false;
extern string Var8 = "---------- (1000) 3 EMA Trend Direction -------------------";
extern int Input_ThreeEMATrendDirection_Timeframe = 1440;
extern int Input_ThreeEMATrendDirection_Shortest = 8;
extern int Input_ThreeEMATrendDirection_Middle = 13;
extern int Input_ThreeEMATrendDirection_Longest = 21;
int Output_ThreeEMATrendDirection = 0;
string Var2 = "------------> Order Entry Section <--------------";
string Var12 = "-------------> Trail Stop Section <--------------------";
extern string Var25 = "--------------> Stop Step Section";
extern string Var14 = "--------------> Break Even Section <-----------------";
string Var15 = "--------------> Add On Orders Section <-------------";
string Var10 = "--------------------------------------------------------------";
extern int MaxSlippage = 3;
extern int VerboseMode = 1;

extern bool SupportECNBrokers = true;
extern bool DisplayInfoPanel = true;


//+------------------------------------------------------------------+
// -- Other Hidden Parameters
//+------------------------------------------------------------------+
bool writeInfoMessagesToLog = false;
double gPointPow = 0;
double gPointCoef = 0;
int lastHistoryPosChecked = 0;
int lastHistoryPosCheckedNT = 0;
string currentTime = "";
string lastTime = "";
double brokerStopDifference = 0;
string sqLastPeriod;
bool sqIsBarOpen;
int signalShift = 0;

int LabelCorner = 1;
int OffsetHorizontal = 5;
int OffsetVertical = 20;
color LabelColor = Black;
int lastOrderErrorCloseTime = 0;

//+------------------------------------------------------------------+
// -- Functions
//+------------------------------------------------------------------+

int init() {
   VerboseLog("--------------------------------------------------------");
   VerboseLog("Starting the EA");

   double realDigits = Digits;
   if(realDigits > 0 && realDigits != 2 && realDigits != 4) {
      realDigits -= 1;
   }

   gPointPow = MathPow(10, realDigits);
   gPointCoef = 1/gPointPow;

   VerboseLog("Broker Stop Difference: ",DoubleToStr(brokerStopDifference*gPointPow, 2));

   VerboseLog("--------------------------------------------------------");

   if(DisplayInfoPanel) {
      ObjectCreate("line1", OBJ_LABEL, 0, 0, 0);
      ObjectSet("line1", OBJPROP_CORNER, LabelCorner);
      ObjectSet("line1", OBJPROP_YDISTANCE, OffsetVertical + 0 );
      ObjectSet("line1", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("line1", "PhoenixTrendTraderv0.014 EA", 9, "Tahoma", LabelColor);

      ObjectCreate("linec", OBJ_LABEL, 0, 0, 0);
      ObjectSet("linec", OBJPROP_CORNER, LabelCorner);
      ObjectSet("linec", OBJPROP_YDISTANCE, OffsetVertical + 16 );
      ObjectSet("linec", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("linec", "Generated by StrategyQuant EA Wizard", 8, "Tahoma", LabelColor);

      ObjectCreate("line2", OBJ_LABEL, 0, 0, 0);
      ObjectSet("line2", OBJPROP_CORNER, LabelCorner);
      ObjectSet("line2", OBJPROP_YDISTANCE, OffsetVertical + 28);
      ObjectSet("line2", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("line2", "------------------------------------------", 8, "Tahoma", LabelColor);

      ObjectCreate("lines", OBJ_LABEL, 0, 0, 0);
      ObjectSet("lines", OBJPROP_CORNER, LabelCorner);
      ObjectSet("lines", OBJPROP_YDISTANCE, OffsetVertical + 44);
      ObjectSet("lines", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("lines", "Last Signal:  -", 9, "Tahoma", LabelColor);

      ObjectCreate("lineopl", OBJ_LABEL, 0, 0, 0);
      ObjectSet("lineopl", OBJPROP_CORNER, LabelCorner);
      ObjectSet("lineopl", OBJPROP_YDISTANCE, OffsetVertical + 60);
      ObjectSet("lineopl", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("lineopl", "Open P/L: -", 8, "Tahoma", LabelColor);

      ObjectCreate("linea", OBJ_LABEL, 0, 0, 0);
      ObjectSet("linea", OBJPROP_CORNER, LabelCorner);
      ObjectSet("linea", OBJPROP_YDISTANCE, OffsetVertical + 76);
      ObjectSet("linea", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("linea", "Account Balance: -", 8, "Tahoma", LabelColor);

      ObjectCreate("lineto", OBJ_LABEL, 0, 0, 0);
      ObjectSet("lineto", OBJPROP_CORNER, LabelCorner);
      ObjectSet("lineto", OBJPROP_YDISTANCE, OffsetVertical + 92);
      ObjectSet("lineto", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("lineto", "Total profits/losses so far: -/-", 8, "Tahoma", LabelColor);

      ObjectCreate("linetp", OBJ_LABEL, 0, 0, 0);
      ObjectSet("linetp", OBJPROP_CORNER, LabelCorner);
      ObjectSet("linetp", OBJPROP_YDISTANCE, OffsetVertical + 108);
      ObjectSet("linetp", OBJPROP_XDISTANCE, OffsetHorizontal);
      ObjectSetText("linetp", "Total P/L so far: -", 8, "Tahoma", LabelColor);
   }

   return(0);
}

//+------------------------------------------------------------------+

int deinit() {
   ObjectDelete("line1");
   ObjectDelete("linec");
   ObjectDelete("line2");
   ObjectDelete("lines");
   ObjectDelete("lineopl");
   ObjectDelete("linea");
   ObjectDelete("lineto");
   ObjectDelete("linetp");
   return(0);
}

//+------------------------------------------------------------------+

int start() {
   if(Bars<30) {
      if(writeInfoMessagesToLog) Print("NOT ENOUGH DATA: Less Bars than 30");
      return(0);
   }

   string currentPeriod = sqGetPeriodAsStr();
   if(currentPeriod == sqLastPeriod) {
      sqIsBarOpen = false;
   } else {
      sqLastPeriod = currentPeriod;
      sqIsBarOpen = true;
   }

   sqTextFillOpens();
   if(sqIsBarOpen) {
      sqTextFillTotals();
   }

   manageOrders();

   //--------------------------------------
   // Initialize 
   if ((Initialized_WaveBreakFlagOn == false))
   {
      // Custom action
      UpdateRobotManagers();
      
   }
   //--------------------------------------
   // Process Debugger 
   if ((0 == 0))
   {
      // Custom action
      debugObject.Write();
      
   }
   //--------------------------------------
   // Okay To Go Long 
   if (((sqGetMarketPosition() == 0) 
      && (GetOrderEntryDirection() == 1)))
   {
      // Custom action
      ProcessOpenOrder(OP_BUY);
      
   }
   //--------------------------------------
   // Okay To Go Short 
   if (((sqGetMarketPosition() == 0) 
      && (GetOrderEntryDirection() == (-1))))
   {
      // Custom action
      ProcessOpenOrder(OP_SELL);
      
   }
   //--------------------------------------
   // Close Long On Change 
   if (((sqGetMarketPosition() == 1) 
      && (GetOrderEntryDirection() != 1)))
   {
      // Custom action
      CloseAllOrdersOnCurrentPair();
      
   }
   //--------------------------------------
   // Close Short On Change 
   if (((sqGetMarketPosition() == -1) 
      && (GetOrderEntryDirection() != (-1))))
   {
      // Custom action
      CloseAllOrdersOnCurrentPair();
      
   }
   //--------------------------------------
   // End of Tick Cleanup 
   if ((0 == 0))
   {
      // Custom action
      debugObject.Clear();
      
   }

   return(0);
}

//+------------------------------------------------------------------+

void manageOrders() {
   for(int i=OrdersTotal()-1; i>=0; i--) {
      if (OrderSelect(i,SELECT_BY_POS)==true) {
         manageOrder(OrderMagicNumber());

         if(sqIsBarOpen) {
            manageOrderExpiration(OrderMagicNumber());
         }
      }

      if(OrdersTotal() <= 0) return;
   }
}

//----------------------------------------------------------------------------

void manageOrder(int orderMagicNumber) {
   double tempValue = 0;
   double tempValue2 = 0;
   double newSL = 0;
   double plValue = 0;
   int error;

}


//----------------------------------------------------------------------------

void manageOrderExpiration(int orderMagicNumber) {
   int tempValue = 0;
   int barsOpen = 0;

}

//----------------------------------------------------------------------------


double getOrderSize(int orderMagicNumber, int orderType) {
   double size = 0;

   return(size);
}

//----------------------------------------------------------------------------

double sqGetAverage(int avgIndiNumber, int period, int maMethod, int signalShiftLocal) {

   double indicatorValue[1000];

   for(int i=0; i<period; i++) {
   }

   double maValue = iMAOnArray(indicatorValue, period, period, 0, maMethod, 0);

   return(maValue);
}


//----------------------------------------------------------------------------

double getOrderPrice(int orderMagicNumber) {
   double price = 0;


   return(NormalizeDouble(price, Digits));
}

//----------------------------------------------------------------------------

double getOrderStopLoss(int orderMagicNumber, int orderType, double price) {
   double value = 0;


   return(NormalizeDouble(value, Digits));
}

//----------------------------------------------------------------------------

double getOrderProfitTarget(int orderMagicNumber, int orderType, double price) {
   double value = 0;


   return(NormalizeDouble(value, Digits));
}

//----------------------------------------------------------------------------

double getOrderExitAfterXBars(int orderMagicNumber) {
   double price = 0;


   return(NormalizeDouble(price, Digits));
}

//----------------------------------------------------------------------------

double getStopDifferencePrice(int orderMagicNumber) {
   double price = 0;


   return(NormalizeDouble(price, Digits));
}

//----------------------------------------------------------------------------

double getOrderTrailingStop(int orderMagicNumber, int orderType, double price) {
   double value = 0;


   return(NormalizeDouble(value, Digits));
}

//----------------------------------------------------------------------------

double getOrderTrailingStopActivation(int orderMagicNumber) {
   double value = 0;


   return(NormalizeDouble(value, Digits));
}

//----------------------------------------------------------------------------

double getOrderBreakEven(int orderMagicNumber, int orderType, double price) {
   double value = 0;


   return(NormalizeDouble(value, Digits));
}

//----------------------------------------------------------------------------

double getOrderBreakEvenAddPips(int orderMagicNumber) {
   double value = 0;


   return(NormalizeDouble(value, Digits));
}

//----------------------------------------------------------------------------

double getOrderExpiration(int orderMagicNumber) {
   double price = 0;


   return(NormalizeDouble(price, Digits));
}

//----------------------------------------------------------------------------

bool getReplaceStopLimitOrder(int orderMagicNumber) {
   bool value = false;


   return(value);
}


//+------------------------------------------------------------------+
//+ Global functions
//+------------------------------------------------------------------+

double sqConvertToRealPips(int value) {
   return(gPointCoef * value);
}

//----------------------------------------------------------------------------

double sqConvertToPips(double value) {
   return(gPointPow * value);
}

//----------------------------------------------------------------------------

double sqSafeDivide(double var1, double var2) {
   if(var2 == 0) return(10000000);
   return(var1/var2);
}

//----------------------------------------------------------------------------

datetime sqGetTime(int hour, int minute, int second) {
   // StrToTime works only on a current date, for previous dates it should be used like this:
   string str = TimeToStr(TimeCurrent(), TIME_DATE)+ " " +hour+ ":" + minute;
   datetime time2 =  StrToTime(str)+second;
   return(time2);
}

//----------------------------------------------------------------------------

double sqHeikenAshi(string symbol, int timeframe, string mode, int shift) {
   if(symbol == "NULL") {
      if(mode == "Open") {
         return(iCustom(NULL, timeframe, "Heiken Ashi", 0,0,0,0, 2, shift));
      }
      if(mode == "Close") {
         return(iCustom(NULL, timeframe, "Heiken Ashi", 0,0,0,0, 3, shift));
      }
      if(mode == "High") {
         return(MathMax(iCustom( NULL, timeframe, "Heiken Ashi", 0,0,0,0, 0, shift), iCustom( NULL, timeframe, "Heiken Ashi", 0,0,0,0, 1, shift)));
      }
      if(mode == "Low") {
         return(MathMin(iCustom( NULL, timeframe, "Heiken Ashi", 0,0,0,0, 0, shift), iCustom( NULL, timeframe, "Heiken Ashi", 0,0,0,0, 1, shift)));
      }

   } else {
      if(mode == "Open") {
         return(iCustom( symbol, timeframe, "Heiken Ashi", 0,0,0,0, 2, shift));
      }
      if(mode == "Close") {
         return(iCustom( symbol, timeframe, "Heiken Ashi", 0,0,0,0, 3, shift));
      }
      if(mode == "High") {
         return(MathMax(iCustom( symbol, timeframe, "Heiken Ashi", 0,0,0,0, 0, shift), iCustom( symbol, timeframe, "Heiken Ashi", 0,0,0,0, 1, shift)));
      }
      if(mode == "Low") {
         return(MathMin(iCustom( symbol, timeframe, "Heiken Ashi", 0,0,0,0, 0, shift), iCustom( symbol, timeframe, "Heiken Ashi", 0,0,0,0, 1, shift)));
      }
   }

   return(-1);
}


//+------------------------------------------------------------------+

double sqHighest(string symbol, int timeframe, int period, int shift) {
   double maxnum = -1000000;
   double val;

   for(int i=shift; i<shift+period; i++) {
      if(symbol == "NULL") {
         val = iHigh(NULL, timeframe, i);
      } else {
         val = iHigh(symbol, timeframe, i);
      }

      if(val > maxnum) {
         maxnum = val;
      }
   }

   return(maxnum);
}

//+------------------------------------------------------------------+

double sqLowest(string symbol, int timeframe, int period, int shift) {
   double minnum = 1000000;
   double val;

   for(int i=shift; i<shift+period; i++) {
      if(symbol == "NULL") {
         val = iLow(NULL, timeframe, i);
      } else {
         val = iLow(symbol, timeframe, i);
      }

      if(val < minnum) {
         minnum = val;
      }
   }

   return(minnum);
}

//+------------------------------------------------------------------+

double sqBiggestRange(string symbol, int timeframe, int period, int shift) {
   double maxnum = -1000;
   double range;

   for(int i=shift; i<shift+period; i++) {
      if(symbol == "NULL") {
         range = iHigh(NULL, timeframe, i) - iLow(NULL, timeframe, i);
      } else {
         range = iHigh(symbol, timeframe, i) - iLow(symbol, timeframe, i);
      }

      if(range > maxnum) {
         maxnum = range;
      }
   }

   return(maxnum);
}


//+------------------------------------------------------------------+

double sqSmallestRange(string symbol, int timeframe, int period, int shift) {
   double minnum = 1000;
   double range;

   for(int i=shift; i<shift+period; i++) {
      if(symbol == "NULL") {
         range = iHigh(NULL, timeframe, i) - iLow(NULL, timeframe, i);
      } else {
         range = iHigh(symbol, timeframe, i) - iLow(symbol, timeframe, i);
      }

      if(range < minnum) {
         minnum = range;
      }
   }

   return(minnum);
}

//+------------------------------------------------------------------+

double sqBarRange(string symbol, int timeframe, int shift) {
   if(symbol == "NULL") {
      return(iHigh(NULL, timeframe, shift) - iLow(NULL, timeframe, shift));
   } else {
      return(iHigh(symbol, timeframe, shift) - iLow(symbol, timeframe, shift));
   }
}

//+------------------------------------------------------------------+

double sqMinimum(double value1, double value2) {
   return(MathMin(value1, value2));
}

//+------------------------------------------------------------------+

double sqMaximum(double value1, double value2) {
   return(MathMax(value1, value2));
}

//+------------------------------------------------------------------+

void Log(string s1, string s2="", string s3="", string s4="", string s5="", string s6="", string s7="", string s8="", string s9="", string s10="", string s11="", string s12="" ) {
   Print(TimeToStr(TimeCurrent()), " ", s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
}


//+------------------------------------------------------------------+

void LogToFile(string fileName, string s1, string s2="", string s3="", string s4="", string s5="", string s6="", string s7="", string s8="", string s9="", string s10="", string s11="", string s12="" ) {
   int handle = FileOpen(fileName, FILE_READ | FILE_WRITE, ";");
   if(handle>0) {
      FileSeek(handle,0,SEEK_END);
      FileWrite(handle, TimeToStr(TimeCurrent()), " ", s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
      FileClose(handle);
   }
}

//+------------------------------------------------------------------+

string sqGetPeriodAsStr() {
   string str = TimeToStr(Time[0], TIME_DATE);
   int period = Period();

   if(period == PERIOD_H4 || period == PERIOD_H1) {
      str = str + TimeHour(Time[0]);
   }
   if(period == PERIOD_M30 || period == PERIOD_M15 || period == PERIOD_M5 || period == PERIOD_M1) {
      str = str + " " + TimeToStr(Time[0], TIME_MINUTES);
   }

   return(str);
}

//+------------------------------------------------------------------+

bool sqDoublesAreEqual(double n1, double n2) {
   string s1 = DoubleToStr(n1, Digits);
   string s2 = DoubleToStr(n2, Digits);

   return (s1 == s2);
}

//+------------------------------------------------------------------+

int sqGetBarsFromOrderOpen(int expBarsPeriod) {
   datetime opTime = OrderOpenTime();

   int numberOfBars = 0;
   for(int i=0; i<expBarsPeriod+10; i++) {
      if(opTime < Time[i]) {
         numberOfBars++;
      }
   }

   return(numberOfBars);
}

//+------------------------------------------------------------------+

int sqGetBarsFromOrderClose(int expBarsPeriod) {
   datetime clTime = OrderCloseTime();

   int numberOfBars = 0;
   for(int i=0; i<expBarsPeriod+10; i++) {
      if(clTime < Time[i]) {
         numberOfBars++;
      }
   }

   return(numberOfBars);
}

//----------------------------------------------------------------------------

void sqCloseOrder(int orderMagicNumber) {
   bool found = false;

   Verbose("Closing order with Magic Number: ", orderMagicNumber, " ----------------");

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == orderMagicNumber) {
         found = true;

         if(OrderType() == OP_BUY || OrderType() == OP_SELL) {
            sqClosePositionAtMarket(-1);
         } else {
            Verbose("Deleting pending order with ticket: ", OrderTicket());
            OrderDelete(OrderTicket());
         }
      }
   }

   if(!found) {
      Verbose("Order cannot be found");
   }
   Verbose("Closing order finished ----------------");
}

//----------------------------------------------------------------------------

void sqCloseAllOrders() {
   bool found = false;

   Verbose("Closing all orders ----------------");

   for(int i=OrdersTotal()-1; i>=0; i--) {
      found = true;

      if (OrderSelect(i,SELECT_BY_POS)==true) {
         if(OrderType() == OP_BUY || OrderType() == OP_SELL) {
            sqClosePositionAtMarket(-1);
         } else {
            Verbose("Deleting pending order");
            OrderDelete(OrderTicket());
         }
      }
   }

   if(!found) {
      Verbose("No orders found");
   }
   Verbose("Closing all orders finished ----------------");
}

//----------------------------------------------------------------------------

void sqCloseOrderPartialPct(int orderMagicNumber, double percentage) {
   double lotMM = sqGetCurrentPositionSize(orderMagicNumber) * (percentage / 100.0);
   int rounding = 2;

   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   if(lotStep == 0.01) {
      rounding = 2;
   } else if(lotStep == 0.1) {
      rounding = 1;
   } else if(lotStep >= 0) {
      rounding = 0;
   }

   lotMM = NormalizeDouble( lotMM, rounding);

   if(MarketInfo(Symbol(), MODE_LOTSIZE)==10000.0) lotMM=lotMM*10.0 ;
   lotMM=NormalizeDouble(lotMM, rounding);

   double Smallest_Lot = MarketInfo(Symbol(), MODE_MINLOT);
   double Largest_Lot = MarketInfo(Symbol(), MODE_MAXLOT);

   if (lotMM < Smallest_Lot) lotMM = Smallest_Lot;
   if (lotMM > Largest_Lot) lotMM = Largest_Lot;

   sqCloseOrderPartial(orderMagicNumber, lotMM);
}

//----------------------------------------------------------------------------

void sqCloseOrderPartial(int orderMagicNumber, double size) {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {

         if(OrderType() == OP_BUY || OrderType() == OP_SELL) {
            if(sqClosePositionAtMarket(size)) return;
         } else {
            if(OrderDelete(OrderTicket())) return;
         }
      }
   }
}

//+------------------------------------------------------------------+

bool sqClosePositionAtMarket(double size) {
   Verbose("Closing order with Magic Number: ", OrderMagicNumber(), ", ticket: ", OrderTicket(), " at market price");

   int error;

   int retries = 3;
   while(true) {
      retries--;
      if(retries < 0) return(false);

      if(sqIsTradeAllowed() == 1) {
         Verbose("Closing retry #", 3-retries);
         if(sqClosePositionWithHandling(size)) {
            // trade successfuly closed
            Verbose("Order with Magic Number: ", OrderMagicNumber(), ", ticket: ", OrderTicket(), " successfuly closed");
            return(true);
         } else {
            error = GetLastError();
            Verbose("Closing order failed, error: ", error," - ", ErrorDescription(error));
         }
      }

      Sleep(500);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqClosePositionWithHandling(double size) {
   RefreshRates();
   double priceCP;

   if(OrderType() != OP_BUY && OrderType() != OP_SELL) {
     return(true);
   }

   if(OrderType() == OP_BUY) {
      priceCP = sqGetBid(OrderSymbol());
   } else {
      priceCP = sqGetAsk(OrderSymbol());
   }

   if(size <= 0) {
      Verbose("Closing Market price: ", priceCP, ", closing size: ", OrderLots());
      return(OrderClose(OrderTicket(), OrderLots(), priceCP, MaxSlippage));
   } else {
      Verbose("Closing Market price: ", priceCP, ", closing size: ", size);
      return(OrderClose(OrderTicket(), size, priceCP, MaxSlippage));
   }
}

//+------------------------------------------------------------------+

bool sqOpenOrder(string symbol, int orderType, double orderLots, double price, string comment, int orderMagicNumber, string ruleName) {
   int ticket;

   Verbose("Opening order with MagicNumber: ", orderMagicNumber,", type: ", sqGetOrderTypeAsString(orderType), ", price: ", price,", lots: ", orderLots, ", comment: ", comment, " ----------------");
   Verbose("Current Ask: ", Ask, ", Bid: ", Bid);

   if(TimeCurrent() - lastOrderErrorCloseTime < 600) {
      return(false);
      Verbose("There was error placing order less that a minute ago, waiting with another order!");
   }
   
   if(sqLiveOrderExists(orderMagicNumber)) {
      Verbose("Order with magic number: ", orderMagicNumber, " already exists, cannot open another one!");
      Verbose("----------------------------------");
      return(false);
   }

   if(sqPendingOrderExists(orderMagicNumber)) {
      if(!getReplaceStopLimitOrder(orderMagicNumber)) {
         Verbose("Pending Order with magic number: ", orderMagicNumber, " already exists, and replace is not allowed!", " ----------------");
         return(false);
      }

      // close pending order
      Verbose("Deleting previous pending order");
      sqDeletePendingOrder(orderMagicNumber);
   }

   RefreshRates();
   if(orderType == OP_BUYSTOP || orderType == OP_SELLSTOP) {
      double AskOrBid;
      if(orderType == OP_BUYSTOP) { AskOrBid = sqGetAsk(symbol); } else { AskOrBid = sqGetBid(symbol); }

      // check if stop/limit price isn't too close
      if(NormalizeDouble(MathAbs(price - AskOrBid), Digits) <= NormalizeDouble(getStopDifferencePrice(orderMagicNumber)/gPointPow, Digits)) {
         Verbose("Stop/limit order is too close to actual price", " ----------------");
         return(false);
      }
   }

   double realSL = getOrderStopLoss(orderMagicNumber, orderType, price);
   double realPT = getOrderProfitTarget(orderMagicNumber, orderType, price);

   int retries = 3;
   while(true) {
      retries--;
      if(retries < 0) return(0);
      if(sqGetOrderPosition(orderMagicNumber) != 0) {
         Verbose("Order already opened", " ----------------");
         return(0);
      }

      if(sqIsTradeAllowed() == 1) {
         Verbose("Opening, try #", 3-retries);
         ticket = sqOpenOrderWithErrorHandling(symbol, orderType, orderLots, price, realSL, realPT, comment, orderMagicNumber);
         if(ticket > 0) {
            // trade successfuly opened
            Verbose("Trade successfuly opened", " ----------------");
            ObjectSetText("lines", "Last Signal: "+ruleName, 8, "Tahoma", LabelColor);

            return(true);
         }
      }

      if(ticket == -130) {
         Verbose("Invalid stops, cannot open the trade", " ----------------");
         return(false);
      }

      if(ticket == -131) {
         // invalid volume, we cannot open the trade
         Verbose("Invalid volume, cannot open the trade", " ----------------");
         return(false);
      }
      
      if(ticket == -11111) {
         Verbose("Trade opened, but cannot set SL/PT, closing trade", " ----------------");
         return(false);
      }
      
      Sleep(1000);
   }

   Verbose("Retries of opening order finished", " ----------------");
   return(false);   
}

//+------------------------------------------------------------------+

int sqIsTradeAllowed(int MaxWaiting_sec = 30) {
    // check whether the trade context is free
    if(!IsTradeAllowed()) {
        int StartWaitingTime = GetTickCount();
        Print("Trade context is busy! Wait until it is free...");
        // infinite loop
        while(true) {
            // if the expert was terminated by the user, stop operation
            if(IsStopped()) {
                Print("The expert was terminated by the user!");
                return(-1);
            }
            // if the waiting time exceeds the time specified in the
            // MaxWaiting_sec variable, stop operation, as well
            int diff = GetTickCount() - StartWaitingTime;
            if(diff > MaxWaiting_sec * 1000) {
                Print("The waiting limit exceeded (" + MaxWaiting_sec + " ???.)!");
                return(-2);
            }
            // if the trade context has become free,
            if(IsTradeAllowed()) {
                Print("Trade context has become free!");
                RefreshRates();
                return(1);
            }
            // if no loop breaking condition has been met, "wait" for 0.1
            // second and then restart checking
            Sleep(100);
          }
    } else {
        //Print("Trade context is free!");
        return(1);
    }
    
    return(1);
}

//+------------------------------------------------------------------+

int sqOpenOrderWithErrorHandling(string symbol, int orderType, double orderLots, double price, double realSL, double realPT, string comment, int orderMagicNumber) {
   int ticket, error;

   Verbose("Sending order...");
   double sl = realSL;
   double pt = realPT;
   if(SupportECNBrokers) {
      sl = 0;
      pt = 0;
   } 
   
   if(symbol == "NULL") {
      ticket = OrderSend(Symbol(), orderType, orderLots, price, MaxSlippage, sl, pt, comment, orderMagicNumber);
   } else {
      ticket = OrderSend(symbol, orderType, orderLots, price, MaxSlippage, sl, pt, comment, orderMagicNumber);
   }
   if(ticket < 0) {
      // order failed, write error to log
      error = GetLastError();
      Verbose("Order failed, error: ", error);
      return(-1*error);
   }

   OrderSelect(ticket, SELECT_BY_TICKET, MODE_TRADES);
         
   Log("Order opened with ticket: ", OrderTicket(), " at price:", OrderOpenPrice());
   VerboseLog("Order with Magic Number: ",orderMagicNumber," opened with ticket: ", OrderTicket(), " at price:", OrderOpenPrice());

   if(SupportECNBrokers) {
      // set up stop loss and profit target
      // it has to be done separately to support ECN brokers

      int retries = 3;
      while(true) {
         retries--;
         if(retries < 0) return(0);
         
         if((realSL == 0 && realPT == 0) || (OrderStopLoss() == realSL && OrderTakeProfit() == realPT)) {
            return(ticket);
         }

         if(sqIsTradeAllowed() == 1) {
            Verbose("Setting SL/PT, try #", 3-retries);
            if(sqSetSLPTForOrder(ticket, realSL, realPT, orderMagicNumber, orderType, price, symbol, retries)) {
               return(ticket);
            }
            if(retries == 0) {
               // there was eror setting SL/PT and order was deleted
               return(-11111);
            }
         }

         Sleep(1000);
      }

      Verbose("Retries of setting SL/PT order finished unsuccessfuly", " ----------------");
      return(-1);
   }

   return(ticket);
}

//+------------------------------------------------------------------+

bool sqSetSLPTForOrder(int ticket, double realSL, double realPT, int orderMagicNumber, int orderType, double price, string symbol, int retries) {
   Verbose("Setting SL: ", realSL, " and PT: ", realPT, " for order");

   if(OrderModify(ticket, OrderOpenPrice(), realSL, realPT, 0, 0)) {
      VerboseLog("Order updates, StopLoss: ", realSL,", Profit Target: ", realPT);
      return(true);
   } else {
      int error = GetLastError();
      VerboseLog("Error modifying order: ",error, " : ", ErrorDescription(error));

      if(retries == 0) {
         // when it is last unsuccessful retry, it tries to close the order
         RefreshRates();
         sqClosePositionAtMarket(-1);
         lastOrderErrorCloseTime = TimeCurrent();
      }
      return(false);
   }
   
   return(true);
}

//+------------------------------------------------------------------+

int sqGetMarketPosition() {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (OrderSelect(cc, SELECT_BY_POS) && OrderSymbol() == Symbol()) {

         if(OrderType() == OP_BUY) {
            return(1);
         }
         if(OrderType() == OP_SELL) {
            return(-1);
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

double sqGetOrderPosition(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if((orderMagicNumber == 0 && OrderSymbol() == Symbol()) || OrderMagicNumber() == orderMagicNumber) {
         if(OrderType() == OP_BUY) {
            return(1);
         }
         if(OrderType() == OP_SELL) {
            return(-1);
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

double sqGetOpenPrice(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if((orderMagicNumber == 0 && OrderSymbol() == Symbol()) || OrderMagicNumber() == orderMagicNumber) {
         return(OrderOpenPrice());
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

double sqGetOrderStopLoss(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
         return(OrderStopLoss());
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

double sqGetOrderProfitTarget(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
         return(OrderTakeProfit());
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

void sqDeletePendingOrder(int orderMagicNumber) {
   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true) {
         if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
            OrderDelete(OrderTicket());
            return;
         }
      }
   }
}

//+------------------------------------------------------------------+

bool sqLiveOrderExists(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderMagicNumber() != orderMagicNumber || OrderSymbol() != Symbol()) continue;
      if(OrderType() != OP_BUY && OrderType() != OP_SELL) continue;

      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqPendingOrderExists(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderMagicNumber() != orderMagicNumber || OrderSymbol() != Symbol()) continue;
      if(OrderType() == OP_BUY || OrderType() == OP_SELL) continue;

      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqIsCandlePattern(int shift, int pattern) {
   if(pattern == PATTERN_DOJI) return(sqCandlePatternDoji(shift));
   if(pattern == PATTERN_HAMMER) return(sqCandlePatternHammer(shift));
   if(pattern == PATTERN_SHOOTING_STAR) return(sqCandlePatternShootingStar(shift));
   if(pattern == PATTERN_DARK_CLOUD) return(sqCandlePatternDarkCloudCover(shift));
   if(pattern == PATTERN_PIERCING_LINE) return(sqCandlePatternPiercingLine(shift));
   if(pattern == PATTERN_BEARISH_ENGULFING) return(sqCandlePatternBearishEngulfing(shift));
   if(pattern == PATTERN_BULLISH_ENGULFING) return(sqCandlePatternBullishEngulfing(shift));

   if(pattern == PATTERN_BEARISH_HARAMI) return(sqCandlePatternBearishHarami(shift));
   if(pattern == PATTERN_BULLISH_HARAMI) return(sqCandlePatternBullishHarami(shift));
   if(pattern == PATTERN_BEARISH_HARAMI_CROSS) return(sqCandlePatternBearishHC(shift));
   if(pattern == PATTERN_BULLISH_HARAMI_CROSS) return(sqCandlePatternBullishHC(shift));

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternDoji(int shift) {
   if(MathAbs(Open[shift] - Close[shift])*gPointPow < 0.6) {
      return(true);
   }
   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternHammer(int shift) {
   double H = High[shift];
   double L = Low[shift];
   double L1 = Low[shift+1];
   double L2 = Low[shift+2];
   double L3 = Low[shift+3];

   double O = Open[shift];
   double C = Close[shift];
   double CL = H-L;

   double BodyLow, BodyHigh;
   double Candle_WickBody_Percent = 0.9;
   double CandleLength = 12;

   if (O > C) {
      BodyHigh = O;
      BodyLow = C;
   } else {
      BodyHigh = C;
      BodyLow = O;
   }

   double LW = BodyLow-L;
   double UW = H-BodyHigh;
   double BLa = MathAbs(O-C);
   double BL90 = BLa*Candle_WickBody_Percent;

   double pipValue = gPointCoef;

   if ((L<=L1)&&(L<L2)&&(L<L3))  {
      if (((LW/2)>UW)&&(LW>BL90)&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((LW/3)<=UW)&&((LW/4)<=UW)/*&&(H<H1)&&(H<H2)*/)  {
         return(true);
      }
      if (((LW/3)>UW)&&(LW>BL90)&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((LW/4)<=UW)/*&&(H<H1)&&(H<H2)*/)  {
         return(true);
      }
      if (((LW/4)>UW)&&(LW>BL90)&&(CL>=(CandleLength*pipValue))&&(O!=C)/*&&(H<H1)&&(H<H2)*/)  {
         return(true);
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternPiercingLine(int shift) {
   double L = Low[shift];
   double H = High[shift];

   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];
   double CL = H-L;

   double CO_HL;
   if((H - L) != 0) {
      CO_HL = (C-O)/(H-L);
   } else {
      CO_HL = 0;
   }

   double Piercing_Line_Ratio = 0.5;
   double Piercing_Candle_Length = 10;

   if ((C1<O1)&&(((O1+C1)/2)<C)&&(O<C) && (CO_HL>Piercing_Line_Ratio)&&(CL>=(Piercing_Candle_Length*gPointCoef))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternShootingStar(int shift) {
   double L = Low[shift];
   double H = High[shift];
   double H1 = High[shift+1];
   double H2 = High[shift+2];
   double H3 = High[shift+3];

   double O = Open[shift];
   double C = Close[shift];
   double CL = H-L;

   double BodyLow, BodyHigh;
   double Candle_WickBody_Percent = 0.9;
   double CandleLength = 12;

   if (O > C) {
      BodyHigh = O;
      BodyLow = C;
   } else {
      BodyHigh = C;
      BodyLow = O;
   }

   double LW = BodyLow-L;
   double UW = H-BodyHigh;
   double BLa = MathAbs(O-C);
   double BL90 = BLa*Candle_WickBody_Percent;

   double pipValue = gPointCoef;

   if ((H>=H1)&&(H>H2)&&(H>H3))  {
      if (((UW/2)>LW)&&(UW>(2*BL90))&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((UW/3)<=LW)&&((UW/4)<=LW)/*&&(L>L1)&&(L>L2)*/)  {
         return(true);
      }
      if (((UW/3)>LW)&&(UW>(2*BL90))&&(CL>=(CandleLength*pipValue))&&(O!=C)&&((UW/4)<=LW)/*&&(L>L1)&&(L>L2)*/)  {
         return(true);
      }
      if (((UW/4)>LW)&&(UW>(2*BL90))&&(CL>=(CandleLength*pipValue))&&(O!=C)/*&&(L>L1)&&(L>L2)*/)  {
         return(true);
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternBearishEngulfing(int shift) {
   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];

   if ((C1>O1)&&(O>C)&&(O>=C1)&&(O1>=C)&&((O-C)>(C1-O1))) {

      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternBullishEngulfing(int shift) {
   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];

   if ((O1>C1)&&(C>O)&&(C>=O1)&&(C1>=O)&&((C-O)>(O1-C1))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternDarkCloudCover(int shift) {
   double L = Low[shift];
   double H = High[shift];

   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];
   double CL = H-L;

   double OC_HL;
   if((H - L) != 0) {
      OC_HL = (O-C)/(H-L);
   } else {
      OC_HL = 0;
   }

   double Piercing_Line_Ratio = 0.5;
   double Piercing_Candle_Length = 10;

   if ((C1>O1)&&(((C1+O1)/2)>C)&&(O>C)&&(C>O1)&&(OC_HL>Piercing_Line_Ratio)&&((CL>=Piercing_Candle_Length*gPointCoef))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternBearishHarami(int shift) {
   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];

   if ((C1>O1)&&(O>C)&&(O<=C1)&&(O1<=C)&&((O-C)<(C1-O1))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternBullishHarami(int shift) {
   double O = Open[shift];
   double O1 = Open[shift+1];
   double C = Close[shift];
   double C1 = Close[shift+1];

   if ((O1>C1)&&(C>O)&&(C<=O1)&&(C1<=O)&&((C-O)<(O1-C1))) {
      return(true);
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqCandlePatternBearishHC(int shift) {
   return (sqCandlePatternBearishHarami(shift) && sqCandlePatternDoji(shift));
}

//+------------------------------------------------------------------+

bool sqCandlePatternBullishHC(int shift) {
   return (sqCandlePatternBullishHarami(shift) && sqCandlePatternDoji(shift));
}

//+------------------------------------------------------------------+


double sqGetOpenPLInPips(int orderMagicNumber) {
   double pl = 0;

   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderType() != OP_BUY && OrderType() != OP_SELL) continue;
      if(OrderSymbol() != Symbol() || (orderMagicNumber != 0 && OrderMagicNumber() != orderMagicNumber)) continue;

      if(OrderType() == OP_BUY) {
         pl += sqGetBid(OrderSymbol()) - OrderOpenPrice();
      } else {
         pl += OrderOpenPrice() - sqGetAsk(OrderSymbol());
      }
   }

   return(pl*gPointPow);
}

//+------------------------------------------------------------------+

int sqGetClosedPLInPips(int orderMagicNumber, int shift) {
   double pl = 0;
   int index = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {

         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(index != shift) {
               index++;
               continue;
            }

            // return the P/L of last order
            // or return the P/L of last order with given Magic Number
            if(OrderType() == OP_BUY) {
               pl = OrderClosePrice() - OrderOpenPrice();
            } else {
               pl = OrderOpenPrice() - OrderClosePrice();
            }
            return(pl*gPointPow);
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

int sqGetTotalClosedPLInPips(int orderMagicNumber, int numberOfLastOrders) {
   double pl = 0;
   int count = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {

         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            // return the P/L of last order
            // or return the P/L of last order with given Magic Number
            count++;
            if(OrderType() == OP_BUY) {
               pl = pl + (OrderClosePrice() - OrderOpenPrice());
            } else {
               pl = pl + (OrderOpenPrice() - OrderClosePrice());
            }

            if(count >= numberOfLastOrders) break;
         }
      }
   }

   return(pl*gPointPow);
}

//+------------------------------------------------------------------+

int sqGetTotalProfits(int orderMagicNumber, int numberOfLastOrders) {
   double pl = 0;
   int count = 0;
   int profits = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {

         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            // return the P/L of last order
            // or return the P/L of last order with given Magic Number
            count++;

            if(OrderType() == OP_BUY) {
               pl = (OrderClosePrice() - OrderOpenPrice());
            } else {
               pl = (OrderOpenPrice() - OrderClosePrice());
            }

            if(pl > 0) {
               profits++;
            }

            if(count >= numberOfLastOrders) break;
         }
      }
   }

   return(profits);
}

//+------------------------------------------------------------------+

int sqGetTotalLosses(int orderMagicNumber, int numberOfLastOrders) {
   double pl = 0;
   int count = 0;
   int losses = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {

         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            // return the P/L of last order
            // or return the P/L of last order with given Magic Number
            count++;

            if(OrderType() == OP_BUY) {
               pl = (OrderClosePrice() - OrderOpenPrice());
            } else {
               pl = (OrderOpenPrice() - OrderClosePrice());
            }

            if(pl < 0) {
               losses++;
            }

            if(count >= numberOfLastOrders) break;
         }
      }
   }

   return(losses);
}

//+------------------------------------------------------------------+

double sqGetOpenPLInMoney(int orderMagicNumber) {
   double pl = 0;

   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderType() != OP_BUY && OrderType() != OP_SELL) continue;
      if(OrderSymbol() != Symbol()) continue;
      if(orderMagicNumber != 0 && OrderMagicNumber() != orderMagicNumber) continue;

      pl += OrderProfit();
   }

   return(pl);
}

//+------------------------------------------------------------------+

int sqGetClosedPLInMoney(int orderMagicNumber, int shift) {
   double pl = 0;
   int index = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(index != shift) {
            index++;
            continue;
         }

         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            // return the P/L of last order or the P/L of last order with given Magic Number
            return(OrderProfit());
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

int sqGetTotalClosedPLInMoney(int orderMagicNumber, int numberOfLastOrders) {
   double pl = 0;
   int count = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            // return the P/L of last order or the P/L of last order with given Magic Number

            count++;
            pl = pl + OrderProfit();

            if(count >= numberOfLastOrders) break;
         }
      }
   }

   return(pl);
}

//+------------------------------------------------------------------+

double sqGetCurrentPositionSize(int orderMagicNumber) {
   double lots = 0;

   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderType() != OP_BUY && OrderType() != OP_SELL) continue;
      if(OrderSymbol() != Symbol()) continue;
      if(orderMagicNumber != 0 && OrderMagicNumber() != orderMagicNumber) continue;

      lots += OrderLots();
   }

   return(lots);
}

//+------------------------------------------------------------------+

double sqGetLastPositionSize(int orderMagicNumber) {
   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            return(OrderLots());
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

void sqMoveSLTo(int orderMagicNumber, double newSL) {
   bool found = false;

   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;

      if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
         found = true;

         Verbose("Moving SL for order with Magic Number: ", orderMagicNumber, ", ticket: ", OrderTicket(), ", new SL: ", newSL);
         OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0);
      }
   }

   if(!found) {
      Verbose("Moving SL - order with Magic Number: ", orderMagicNumber, " wasn't found");
   }
}

//+------------------------------------------------------------------+

void sqMovePTTo(int orderMagicNumber, double newPT) {
   bool found = false;

   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;

      if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
         found = true;

         Verbose("Moving PT for order with Magic Number: ", orderMagicNumber,", ticket: ", OrderTicket(), ", new PT: ", newPT);
         OrderModify(OrderTicket(), OrderOpenPrice(), OrderStopLoss(), newPT, 0);
      }
   }

   if(!found) {
      Verbose("Moving PT - order with Magic Number: ", orderMagicNumber, " wasn't found");
   }
}

//+------------------------------------------------------------------+


int sqGetBarsSinceEntry(int orderMagicNumber) {
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (OrderSelect(cc, SELECT_BY_POS) ) {

         if((orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) && OrderSymbol() == Symbol()) {
            return (sqGetBarsFromOrderOpen(1000));
         }
      }
   }

   return(-1);
}

//+------------------------------------------------------------------+

int sqGetBarsSinceExit(int orderMagicNumber) {

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true) {

         if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
            return (sqGetBarsFromOrderClose(1000));
         }
      }
   }

   return(-1);
}

//+------------------------------------------------------------------+

int sqGetOpenBarsForOrder(int expBarsPeriod) {
   datetime opTime = OrderOpenTime();

   int numberOfBars = 0;
   for(int i=0; i<expBarsPeriod+10; i++) {
      if(opTime < Time[i]) {
         numberOfBars++;
      }
   }

   return(numberOfBars);
}

//+------------------------------------------------------------------+

int sqGetOrdersOpenedToday(int direction, string includePending) {
   string todayTime = TimeToStr( TimeCurrent(), TIME_DATE);
   int tradesOpenedToday = 0;

   for(int i=0;i<OrdersHistoryTotal();i++) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {

         if(direction == 1) {
            if(OrderType() == OP_SELL || OrderType() == OP_SELLLIMIT || OrderType() == OP_SELLSTOP) {
               // skip short orders
               continue;
            }
         } else if(direction == -1) {
            if(OrderType() == OP_BUY || OrderType() == OP_BUYLIMIT || OrderType() == OP_BUYSTOP) {
               // skip long orders
               continue;
            }
         }

         if(includePending == "false") {
            if(OrderType() == OP_BUYLIMIT || OrderType() == OP_BUYSTOP || OrderType() == OP_SELLLIMIT || OrderType() == OP_SELLSTOP) {
               // skip pending orders
               continue;
            }
         }

         if(TimeToStr( OrderOpenTime(), TIME_DATE) == todayTime) {
            tradesOpenedToday++;
         }
      }
   }

   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (OrderSelect(cc, SELECT_BY_POS) && OrderSymbol() == Symbol()) {

         if(direction == 1) {
            if(OrderType() == OP_SELL || OrderType() == OP_SELLLIMIT || OrderType() == OP_SELLSTOP) {
               // skip short orders
               continue;
            }
         } else if(direction == -1) {
            if(OrderType() == OP_BUY || OrderType() == OP_BUYLIMIT || OrderType() == OP_BUYSTOP) {
               // skip long orders
               continue;
            }
         }

         if(includePending == "false") {
            if(OrderType() == OP_BUYLIMIT || OrderType() == OP_BUYSTOP || OrderType() == OP_SELLLIMIT || OrderType() == OP_SELLSTOP) {
               // skip pending orders
               continue;
            }
         }

         if(TimeToStr( OrderOpenTime(), TIME_DATE) == todayTime) {
            tradesOpenedToday++;
         }
      }
   }

   return(tradesOpenedToday);
}

//+------------------------------------------------------------------+

int sqGetLastOrderType() {
   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(OrderType() == OP_BUY) {
            return(1);
         }
         if(OrderType() == OP_SELL) {
            return(-1);
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

int sqGetLastOrderTodayType() {
   string todayTime = TimeToStr( TimeCurrent(), TIME_DATE);

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(TimeToStr( OrderOpenTime(), TIME_DATE) != todayTime) {
            continue;
         }

         if(OrderType() == OP_BUY) {
            return(1);
         }
         if(OrderType() == OP_SELL) {
            return(-1);
         }
      }
   }

   return(0);
}

//+------------------------------------------------------------------+

bool sqOrderOpenedThisBar(int orderMagicNumber) {
   double pl = 0;

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderOpenTime() > Time[1]) {
               return(true);
            }
         }
      }
   }

   for(i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderOpenTime() > Time[1]) {
               return(true);
            }
         }
      }
   }


   return(false);
}

//+------------------------------------------------------------------+

bool sqOrderClosedThisBar(int orderMagicNumber) {
   double pl = 0;

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderCloseTime() > Time[1]) {
               return(true);
            }
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqOrderOpenedThisMinute(int orderMagicNumber) {
   datetime timeCandle = TimeCurrent() - 60; //iTime(NULL, PERIOD_M1, 1);

   for(int i=0; i<OrdersTotal(); i++) {
      if (OrderSelect(i,SELECT_BY_POS)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderOpenTime() >= timeCandle) {
               return(true);
            }
         }
      }
   }

   for(i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderOpenTime() >= timeCandle) {
               return(true);
            }
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

bool sqOrderClosedThisMinute(int orderMagicNumber) {
   datetime timeCandle = TimeCurrent() - 60; //iTime(NULL, PERIOD_M1, 1);

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderCloseTime() >= timeCandle) {
               return(true);
            }
         }
      }
   }

   return(false);
}

//+------------------------------------------------------------------+

double sqGetAngle(double value1, double value2, int period, double coef) {
   double diff = value1 - value2;

   double fAngleRad = MathArctan(diff / (coef*period));
   double PI =  3.141592654;

   double fAngleDegrees = (fAngleRad * 180) / PI;

   return((fAngleDegrees));
}

//+------------------------------------------------------------------+

string sqGetOrderSymbol(int orderMagicNumber) {
   datetime timeCandle = TimeCurrent() - 60; //iTime(NULL, PERIOD_M1, 1);

   for(int i=OrdersHistoryTotal(); i>=0; i--) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderSymbol() == Symbol()) {
         if(orderMagicNumber == 0 || OrderMagicNumber() == orderMagicNumber) {
            if(OrderCloseTime() >= timeCandle) {
               return(OrderSymbol());
            }
         }
      }
   }

   return("");
}

//+------------------------------------------------------------------+

void sqTextFillOpens() {
   ObjectSetText("lineopl", "Open P/L: "+DoubleToStr(sqGetOpenPLInMoney(0), 2), 8, "Tahoma", LabelColor);
   ObjectSetText("linea", "Account Balance: "+DoubleToStr(AccountBalance(), 2) , 8, "Tahoma", LabelColor);
}

//+------------------------------------------------------------------+

void sqTextFillTotals() {
   ObjectSetText("lineto", "Total profits/losses so far: "+sqGetTotalProfits(0, 100)+"/"+sqGetTotalLosses(0, 100), 8, "Tahoma", LabelColor);
   ObjectSetText("linetp", "Total P/L so far: "+DoubleToStr(sqGetTotalClosedPLInMoney(0, 1000), 2), 8, "Tahoma", LabelColor);
}

//+------------------------------------------------------------------+

double sqHighestInRange(string symbol, int timeframe, string timeFrom, string timeTo) {
   int indexTo = -1;
   int indexFrom = -1;

   // find index of bar for timeTo
   for(int i=1; i<=2000; i++) {
      if(TimeToStr(Time[i], TIME_MINUTES) >= timeTo && TimeToStr(Time[i+1], TIME_MINUTES) < timeTo) {
         //Log("Found timeTo: ", TimeToStr(Time[i]));
         indexTo = i;
         break;
      }
   }

   if(indexTo == -1) {
      Log("Not found timeTo");
      return(-1);
   }

   // find index of bar for timeFrom
   for(i=indexTo+1; i<=2000; i++) {
      if(TimeToStr(Time[i], TIME_MINUTES) >= timeFrom && TimeToStr(Time[i+1], TIME_MINUTES) < timeFrom) {
         //Log("Found timeFrom: ", TimeToStr(Time[i]));
         indexFrom = i;
         break;
      }
   }

   if(indexFrom == -1) {
      Log("Not found time From");
      return(-1);
   }

   double value = -10000.0;

   for(i=indexTo; i<=indexFrom; i++) {
      if(symbol == "NULL") {
         value = MathMax(value, iHigh(NULL, timeframe, i));
      } else {
         value = MathMax(value, iHigh(symbol, timeframe, i));
      }
   }

   return(value);
}

//+------------------------------------------------------------------+

double sqLowestInRange(string symbol, int timeframe, string timeFrom, string timeTo) {
   int indexTo = -1;
   int indexFrom = -1;

   // find index of bar for timeTo
   for(int i=1; i<=2000; i++) {
      if(TimeToStr(Time[i], TIME_MINUTES) >= timeTo && TimeToStr(Time[i+1], TIME_MINUTES) < timeTo) {
         //Log("Found timeTo: ", TimeToStr(Time[i]));
         indexTo = i;
         break;
      }
   }

   if(indexTo == -1) {
      Log("Not found timeTo");
      return(-1);
   }

   // find index of bar for timeFrom
   for(i=indexTo+1; i<=2000; i++) {
      if(TimeToStr(Time[i], TIME_MINUTES) >= timeFrom && TimeToStr(Time[i+1], TIME_MINUTES) < timeFrom) {
         //Log("Found timeFrom: ", TimeToStr(Time[i]));
         indexFrom = i;
         break;
      }
   }

   if(indexFrom == -1) {
      Log("Not found time From");
      return(-1);
   }

   double value = 100000.0;

   for(i=indexTo; i<=indexFrom; i++) {
      if(symbol == "NULL") {
         value = MathMin(value, iLow(NULL, timeframe, i));
      } else {
         value = MathMin(value, iLow(symbol, timeframe, i));
      }
   }

   return(value);
}

//+------------------------------------------------------------------+

double sqGetOrdersAveragePrice(int orderMagicNumber) {
   double sum = 0.0;
   double cnt = 0.0;
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if(OrderMagicNumber() == orderMagicNumber && OrderSymbol() == Symbol()) {
         if(OrderType() == OP_BUY && OrderCloseTime() == 0) {
            sum += OrderLots() * OrderOpenPrice ();
            cnt += OrderLots();
         }
         if(OrderType() == OP_SELL && OrderCloseTime() == 0) {
            sum += OrderLots() * OrderOpenPrice ();
			   cnt += OrderLots();
         }
      }
   }

   if (NormalizeDouble (cnt, Digits) == 0) return (0);

   return(sum / cnt);
}

//+------------------------------------------------------------------+

double sqGetIf (double condition, double val1, double val2) {
	if (NormalizeDouble(condition, Digits) > 0) return (val1);
	return (val2);
}

//+------------------------------------------------------------------+

double sqRound(double value, int digits) {
   double pow = MathPow(10, digits);
   return(MathRound(value * pow) / pow);
}

//+------------------------------------------------------------------+

double sqGetAsk(string symbol) {
   if(symbol == "NULL") {
      return(Ask);
   } else {
      return(MarketInfo(symbol,MODE_ASK));
   }
}

//+------------------------------------------------------------------+

double sqGetBid(string symbol) {
   if(symbol == "NULL") {
      return(Bid);
   } else {
      return(MarketInfo(symbol,MODE_BID));
   }
}

//+------------------------------------------------------------------+

string sqGetOrderTypeAsString(int type) {
   switch(type) {
      case OP_BUY: return("Buy");
      case OP_SELL: return("Sell");
      case OP_BUYLIMIT: return("Buy Limit");
      case OP_BUYSTOP: return("Buy Stop");
      case OP_SELLLIMIT: return("Sell Limit");
      case OP_SELLSTOP: return("Sell Stop");
   }

   return("Unknown");
}

//+------------------------------------------------------------------+

void Verbose(string s1, string s2="", string s3="", string s4="", string s5="", string s6="", string s7="", string s8="", string s9="", string s10="", string s11="", string s12="" ) {
   if(VerboseMode == 1) {
      // log to standard log
      Print("---VERBOSE--- ", TimeToStr(TimeCurrent()), " ", s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);

   } else if(VerboseMode == 2) {
      // log to special file
      int handle = FileOpen("EAW_VerboseLog.txt", FILE_READ | FILE_WRITE);
      if(handle>0) {
         FileSeek(handle,0,SEEK_END);
         FileWrite(handle, TimeToStr(TimeCurrent()), " VERBOSE: ", s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
         FileClose(handle);
      }
   }
}

//+------------------------------------------------------------------+

void VerboseLog(string s1, string s2="", string s3="", string s4="", string s5="", string s6="", string s7="", string s8="", string s9="", string s10="", string s11="", string s12="" ) {
   if(VerboseMode != 1) {
      Log(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
   }

   Verbose(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
}

//+------------------------------------------------------------------+

double sqCICheck(double value) {
   if(value >= 2147483647) return(0);
   return(value);
}

//+------------------------------------------------------------------+

void sqDrawUpArrow(int shift) {
   string name = StringConcatenate("Arrow_", MathRand());

   ObjectCreate(name, OBJ_ARROW, 0, Time[shift], Low[shift]-20*Point); //draw an up arrow
   ObjectSet(name, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSet(name, OBJPROP_ARROWCODE, SYMBOL_ARROWUP);
   ObjectSet(name, OBJPROP_COLOR, Green);
}

//+------------------------------------------------------------------+

void sqDrawDownArrow(int shift) {
   string name = StringConcatenate("Arrow_", MathRand());

   ObjectCreate(name, OBJ_ARROW, 0, Time[shift], High[shift]+140*Point); //draw an down arrow
   ObjectSet(name, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSet(name, OBJPROP_ARROWCODE, SYMBOL_ARROWDOWN);
   ObjectSet(name, OBJPROP_COLOR, Red);
}

//+------------------------------------------------------------------+

string sqDateCurrent(int shift) {
   return(TimeToStr(Time[shift], TIME_DATE));
}

//+------------------------------------------------------------------+

string sqGetDate(int day, int month, int year) {
   string strMonth = month;
   if(month < 10) strMonth = "0"+strMonth;

   string strDay = day;
   if(day < 10) strDay = "0"+strDay;

   return(StringConcatenate(year, ".", strMonth, ".", strDay));
}

//+------------------------------------------------------------------+
//| return error description                                         |
//+------------------------------------------------------------------+
string ErrorDescription(int error_code)
  {
   string error_string;
//----
   switch(error_code)
     {
      //---- codes returned from trade server
      case 0:
      case 1:   error_string="no error";                                                  break;
      case 2:   error_string="common error";                                              break;
      case 3:   error_string="invalid trade parameters";                                  break;
      case 4:   error_string="trade server is busy";                                      break;
      case 5:   error_string="old version of the client terminal";                        break;
      case 6:   error_string="no connection with trade server";                           break;
      case 7:   error_string="not enough rights";                                         break;
      case 8:   error_string="too frequent requests";                                     break;
      case 9:   error_string="malfunctional trade operation (never returned error)";      break;
      case 64:  error_string="account disabled";                                          break;
      case 65:  error_string="invalid account";                                           break;
      case 128: error_string="trade timeout";                                             break;
      case 129: error_string="invalid price";                                             break;
      case 130: error_string="invalid stops";                                             break;
      case 131: error_string="invalid trade volume";                                      break;
      case 132: error_string="market is closed";                                          break;
      case 133: error_string="trade is disabled";                                         break;
      case 134: error_string="not enough money";                                          break;
      case 135: error_string="price changed";                                             break;
      case 136: error_string="off quotes";                                                break;
      case 137: error_string="broker is busy (never returned error)";                     break;
      case 138: error_string="requote";                                                   break;
      case 139: error_string="order is locked";                                           break;
      case 140: error_string="long positions only allowed";                               break;
      case 141: error_string="too many requests";                                         break;
      case 145: error_string="modification denied because order too close to market";     break;
      case 146: error_string="trade context is busy";                                     break;
      case 147: error_string="expirations are denied by broker";                          break;
      case 148: error_string="amount of open and pending orders has reached the limit";   break;
      case 149: error_string="hedging is prohibited";                                     break;
      case 150: error_string="prohibited by FIFO rules";                                  break;
      //---- mql4 errors
      case 4000: error_string="no error (never generated code)";                          break;
      case 4001: error_string="wrong function pointer";                                   break;
      case 4002: error_string="array index is out of range";                              break;
      case 4003: error_string="no memory for function call stack";                        break;
      case 4004: error_string="recursive stack overflow";                                 break;
      case 4005: error_string="not enough stack for parameter";                           break;
      case 4006: error_string="no memory for parameter string";                           break;
      case 4007: error_string="no memory for temp string";                                break;
      case 4008: error_string="not initialized string";                                   break;
      case 4009: error_string="not initialized string in array";                          break;
      case 4010: error_string="no memory for array\' string";                             break;
      case 4011: error_string="too long string";                                          break;
      case 4012: error_string="remainder from zero divide";                               break;
      case 4013: error_string="zero divide";                                              break;
      case 4014: error_string="unknown command";                                          break;
      case 4015: error_string="wrong jump (never generated error)";                       break;
      case 4016: error_string="not initialized array";                                    break;
      case 4017: error_string="dll calls are not allowed";                                break;
      case 4018: error_string="cannot load library";                                      break;
      case 4019: error_string="cannot call function";                                     break;
      case 4020: error_string="expert function calls are not allowed";                    break;
      case 4021: error_string="not enough memory for temp string returned from function"; break;
      case 4022: error_string="system is busy (never generated error)";                   break;
      case 4050: error_string="invalid function parameters count";                        break;
      case 4051: error_string="invalid function parameter value";                         break;
      case 4052: error_string="string function internal error";                           break;
      case 4053: error_string="some array error";                                         break;
      case 4054: error_string="incorrect series array using";                             break;
      case 4055: error_string="custom indicator error";                                   break;
      case 4056: error_string="arrays are incompatible";                                  break;
      case 4057: error_string="global variables processing error";                        break;
      case 4058: error_string="global variable not found";                                break;
      case 4059: error_string="function is not allowed in testing mode";                  break;
      case 4060: error_string="function is not confirmed";                                break;
      case 4061: error_string="send mail error";                                          break;
      case 4062: error_string="string parameter expected";                                break;
      case 4063: error_string="integer parameter expected";                               break;
      case 4064: error_string="double parameter expected";                                break;
      case 4065: error_string="array as parameter expected";                              break;
      case 4066: error_string="requested history data in update state";                   break;
      case 4099: error_string="end of file";                                              break;
      case 4100: error_string="some file error";                                          break;
      case 4101: error_string="wrong file name";                                          break;
      case 4102: error_string="too many opened files";                                    break;
      case 4103: error_string="cannot open file";                                         break;
      case 4104: error_string="incompatible access to a file";                            break;
      case 4105: error_string="no order selected";                                        break;
      case 4106: error_string="unknown symbol";                                           break;
      case 4107: error_string="invalid price parameter for trade function";               break;
      case 4108: error_string="invalid ticket";                                           break;
      case 4109: error_string="trade is not allowed in the expert properties";            break;
      case 4110: error_string="longs are not allowed in the expert properties";           break;
      case 4111: error_string="shorts are not allowed in the expert properties";          break;
      case 4200: error_string="object is already exist";                                  break;
      case 4201: error_string="unknown object property";                                  break;
      case 4202: error_string="object is not exist";                                      break;
      case 4203: error_string="unknown object type";                                      break;
      case 4204: error_string="no object name";                                           break;
      case 4205: error_string="object coordinates error";                                 break;
      case 4206: error_string="no specified subwindow";                                   break;
      default:   error_string="unknown error";
     }
//----
   return(error_string);
  }
//+------------------------------------------------------------------+
//| convert red, green and blue values to color                      |
//+------------------------------------------------------------------+
int RGB(int red_value,int green_value,int blue_value)
  {
//---- check parameters
   if(red_value<0)     red_value=0;
   if(red_value>255)   red_value=255;
   if(green_value<0)   green_value=0;
   if(green_value>255) green_value=255;
   if(blue_value<0)    blue_value=0;
   if(blue_value>255)  blue_value=255;
//----
   green_value<<=8;
   blue_value<<=16;
   return(red_value+green_value+blue_value);
  }
//+------------------------------------------------------------------+
//| right comparison of 2 doubles                                    |
//+------------------------------------------------------------------+
bool CompareDoubles(double number1,double number2)
  {
   if(NormalizeDouble(number1-number2,8)==0) return(true);
   else return(false);
  }
//+------------------------------------------------------------------+
//| up to 16 digits after decimal point                              |
//+------------------------------------------------------------------+
string DoubleToStrMorePrecision(double number,int precision)
  {
   double rem,integer,integer2;
   double DecimalArray[17]={ 1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0,  10000000.0, 100000000.0,
                             1000000000.0, 10000000000.0, 100000000000.0, 10000000000000.0, 100000000000000.0,
                             1000000000000000.0, 1000000000000000.0, 10000000000000000.0 };
   string intstring,remstring,retstring;
   bool   isnegative=false;
   int    rem2;
//----
   if(precision<0)  precision=0;
   if(precision>16) precision=16;
//----
   double p=DecimalArray[precision];
   if(number<0.0) { isnegative=true; number=-number; }
   integer=MathFloor(number);
   rem=MathRound((number-integer)*p);
   remstring="";
   for(int i=0; i<precision; i++)
     {
      integer2=MathFloor(rem/10);
      rem2=NormalizeDouble(rem-integer2*10,0);
      remstring=rem2+remstring;
      rem=integer2;
     }
//----
   intstring=DoubleToStr(integer,0);
   if(isnegative) retstring="-"+intstring;
   else           retstring=intstring;
   if(precision>0) retstring=retstring+"."+remstring;
   return(retstring);
  }
//+------------------------------------------------------------------+
//| convert integer to string contained input's hexadecimal notation |
//+------------------------------------------------------------------+
string IntegerToHexString(int integer_number)
  {
   string hex_string="00000000";
   int    value, shift=28;
//   Print("Parameter for IntegerHexToString is ",integer_number);
//----
   for(int i=0; i<8; i++)
     {
      value=(integer_number>>shift)&0x0F;
      if(value<10) hex_string=StringSetChar(hex_string, i, value+'0');
      else         hex_string=StringSetChar(hex_string, i, (value-10)+'A');
      shift-=4;
     }
//----
   return(hex_string);
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//+ Money Management functions
//+------------------------------------------------------------------+

double sqMMGetOrderStopLossDistance(int orderMagicNumber, int orderType) {
   double openPrice = getOrderPrice(orderMagicNumber);
   double slSize = getOrderStopLoss(orderMagicNumber, orderType, openPrice);

   if(slSize == 0) return(0);

   if(orderType == OP_BUY || orderType == OP_BUYSTOP || orderType == OP_BUYLIMIT) {
      return(openPrice - slSize);
   } else {
      return(slSize - openPrice);
   }
}



double sqMMFixed(int orderMagicNumber, int orderType) {
   Verbose("Money Management for order with MN: ", orderMagicNumber," - fixed lots: ", 0.1);
   return (0.1);
}
//+------------------------------------------------------------------------------------------+
//+ Phoenix Trend Trader Library v0.012
//+
//+------------------------------------------------------------------------------------------+
//

//Class definitions
class DebugObject{
   public:
      string DebugText;
      
      void Add(string text)
      {
         DebugText=StringConcatenate(DebugText,text);
      }
      
      void Clear()
      {
         DebugText = "";
      }
      
      void Write()
      {
         Comment(DebugText);
      }
};

class DirectionByColorValue{
   public:
      long GreenColor;  
      long RedColor;   
      long YellowColor; 
   
   DirectionByColorValue()
   {
      GreenColor=Green;
      RedColor=Red;
      YellowColor=Yellow;
   }
};

class DirectionByName{
   public:
      string GreenName;  
      string RedName;   
      string YellowName;
   
   DirectionByName()
   {
      GreenName="Green";
      RedName="Red";
      YellowName="Yellow";
   }
};

//Direction object that can be used throughout application.
class DirectionByIntValue{
   public:
      int LongIntValue;
      int ShortIntValue;
      int NeutralIntValue;
   
   DirectionByIntValue()
   {
      LongIntValue=1;
      ShortIntValue=-1;
      NeutralIntValue=0;
   }
};

class WavePointClusterObject{
   DirectionByIntValue Direction;
   
   public:
      int BarStart;  
      int BarEnd;
      int ClusterType;
      
   WavePointClusterObject()
   {
      BarStart=0;  
      BarEnd=0;
      ClusterType=Direction.NeutralIntValue;
   }
};

class PivotTypes{
   public:
      string HighPivot;
      string LowPivot;
      string IndeterminatePivot;
   
   PivotTypes()
   {
      HighPivot = "High";
      LowPivot = "Low";
      IndeterminatePivot = "Indeterminate";
   }
};

class PivotPointObject{
   public:
      double PivotPrice;
      int PivotBar;  
      string PivotType;
      datetime PivotDate;
      
   PivotPointObject()
   {
      PivotPrice = 0;
      PivotBar = 0;
      PivotType = pivotType.IndeterminatePivot;
   }
};

class TriangleBreakoutObject{
   DirectionByIntValue Direction;
   
   public:
      double Price1;
      double Price2;
      double Price3;
      datetime DateTime1;
      datetime DateTime2;
      datetime DateTime3;
      int Bar1;
      int Bar2;
      int Bar3;
      int TriangleDirection;
      
   TriangleBreakoutObject()
   {
      Direction.NeutralIntValue;
   }
};

class BreakoutLineObject{
   DirectionByIntValue Direction;
   
   public:
      int x1;     //Origin Point Bar Coordinate
      double y1;  //Origin Point Price Coordinate
      
      int x2;     //Destination Point Bar Coordinate
      double y2;  //Destination Point Price Coordinate 

      int x3;     //End Point Bar Coordinate
      double y3;  //End Point Price Coordinate 

      double m;   //Slope of line from (x1,y1) to (x2,y2)
      
      double b;   //y-intercept
      
      int BreakoutLineTrend;

    BreakoutLineObject()
    {
      BreakoutLineTrend = Direction.NeutralIntValue;
    }
};


//This class holds all of the results of our calculations that are needed to decide order entry, order managmeent, and add-ons. Basically
//if you have this object, you hold everything needed to take actions. However, there are managers that use these values to perform 
//more specific jobs. For example, the WaveBreakOrderEntryManager will hold all information needed to enter an order.
class WaveBreakManager{
   public:
      int WaveBreakTimeframe;
      int WaveBreakPivotPointsToTrack;
      bool InitializedWaveBreakFlagOn;
      bool ClusterObjectDebugFlagOn;
      bool PivotBarDebugFlagOn;
      bool TriangleBreakoutDebugFlagOn;
      bool BreakoutLineDebugFlagOn;
      bool BreakoutLinePriceDebugFlagOn;
      bool CurrentCandleColorCorrectDebugFlagOn;
      bool PreviousCandleColorCorrectDebugFlagOn;
      bool CurrentOpenPastPreviousOpenDebugFlagOn;
      bool TrianglePointOneNotVioloatedDebugFlagOn;
      bool CurrentTriangleIndexNumberDebugFlagOn;
      
   WaveBreakManager()
   {
      InitializedWaveBreakFlagOn=Initialized_WaveBreakFlagOn;
      BreakoutLineDebugFlagOn=Debug_BreakoutLineDebugFlagOn;
      BreakoutLinePriceDebugFlagOn=Debug_BreakoutLinePriceDebugFlagOn;
      ClusterObjectDebugFlagOn=Debug_ClusterObjectDebugFlagOn;
      PivotBarDebugFlagOn=Debug_PivotBarDebugFlagOn;
      TriangleBreakoutDebugFlagOn=Debug_TriangleBreakoutDebugFlagOn;
      WaveBreakTimeframe=Input_WaveBreak_Timeframe;
      WaveBreakPivotPointsToTrack=Input_WaveBreakPivotPointsToTrack;
      CurrentCandleColorCorrectDebugFlagOn=Debug_CurrentCandleColorCorrectFlagOn;
      PreviousCandleColorCorrectDebugFlagOn=Debug_PreviousCandleColorCorrectFlagOn;
      CurrentOpenPastPreviousOpenDebugFlagOn=Debug_CurrentOpenPastPreviousOpenFlagOn;
      TrianglePointOneNotVioloatedDebugFlagOn = Debug_TrianglePointOneNotviolatedFlagOn;
      CurrentTriangleIndexNumberDebugFlagOn = Debug_CurrentTriangleIndexNumberFlagOn;
   }
};

class WaveBreakOrderEntryManager{
   public:
      int ThreeEMATrendDirection; 
      int BreakoutPriceFlag;
      int TriangleBreakoutDirection;
      int TradeDirection;
      int PivotLineType;
      
      bool CurrentOpenPastPreviousOpenFlag;
      bool OkayToEnterTrade; 
      bool WaveBreakOrderEntryManagerFlagOn;
      bool CurrentCandleColorCorrectFlag;
      bool PreviousCandleColorCorrectFlag;
      bool TrianglePointOneNotViolatedFlag;
   
   WaveBreakOrderEntryManager()
   {
      ThreeEMATrendDirection = directionByIntValue.NeutralIntValue;
      BreakoutPriceFlag = false;
      TriangleBreakoutDirection = directionByIntValue.NeutralIntValue;
      TradeDirection = directionByIntValue.NeutralIntValue;
      PivotLineType = directionByIntValue.NeutralIntValue;
      CurrentOpenPastPreviousOpenFlag=false;
      OkayToEnterTrade = false; 
      CurrentCandleColorCorrectFlag = false;
      PreviousCandleColorCorrectFlag = false;
      WaveBreakOrderEntryManagerFlagOn = Debug_WaveBreakOrderEntryManagerFlagOn;
      TrianglePointOneNotViolatedFlag=false;
   }
   
};

class TripleEMAMovingAverageManager{
   public:
      int ThreeEMATrendDirection_Timeframe;
      int ThreeEMATrendDirection_Shortest;
      int ThreeEMATrendDirection_Middle;
      int ThreeEMATrendDirection_Longest;
      int ThreeEMATrendDirection;
      bool ThreeEMATrendDirectionDebugFlagOn;

   TripleEMAMovingAverageManager()
   {
      ThreeEMATrendDirection_Timeframe=Input_ThreeEMATrendDirection_Timeframe;
      ThreeEMATrendDirection_Shortest=Input_ThreeEMATrendDirection_Shortest;
      ThreeEMATrendDirection_Middle=Input_ThreeEMATrendDirection_Middle;
      ThreeEMATrendDirection_Longest=Input_ThreeEMATrendDirection_Longest;
      ThreeEMATrendDirection = Input_ThreeEMATrendDirection_Longest;
      ThreeEMATrendDirectionDebugFlagOn = Debug_ThreeEMATrendDirectionFlagOn;
      ThreeEMATrendDirection=directionByIntValue.NeutralIntValue;
   }
};

class CurrentBreakoutLinePriceManager{
   public:
      double CurrentBreakoutLastOpenPrice;
      double BreakoutPriceFlag;

   CurrentBreakoutLinePriceManager()
   {
      CurrentBreakoutLastOpenPrice = 0;
      BreakoutPriceFlag=false;
   }
};

class CurrentTriangleBreakoutDirection{
   public:
      int TriangleDirection;
      bool CurrentTriangleBreakoutDirectionFlagOn;
   CurrentTriangleBreakoutDirection()
   {
      TriangleDirection = directionByIntValue.NeutralIntValue;
      CurrentTriangleBreakoutDirectionFlagOn=Debug_CurrentTriangleBreakoutDirectionFlagOn;
   }
};

//Functions
void UpdateRobotManagers()
{
   ProcessWaveBreak(NULL,wbm.WaveBreakTimeframe);
   CreateBreakoutTriangles(NULL,wbm.WaveBreakTimeframe,0,wbm.WaveBreakPivotPointsToTrack);
   UpdateTripleEMAMovingAverageManager();
   UpdateCurrentBreakoutPriceFlagManager();
   UpdateTriangleBreakoutDirection();
   UpdateWaveBreakOrderEntryManager();
   
   
   //Temporary
   CloseOrdersOnDirectionChange();
   
}

void UpdateTripleEMAMovingAverageManager()
{
   temamam.ThreeEMATrendDirection=GetTrendFromEMA();

   if(temamam.ThreeEMATrendDirectionDebugFlagOn)
   {
      debugObject.Add
      (
         " Direction: " + temamam.ThreeEMATrendDirection + "\n\n"
      );
   }
}

int GetCurrentTriangleIndexNumber()
{
   int indexNumber = -1;

   for(int x=0;x<ArrayRange(tboo,0);x++)
   {
      if(tboo[x].TriangleDirection != directionByIntValue.NeutralIntValue)
      {
         indexNumber = x;
         break;
      }
   }

   //Save Debug Info
   if(wbm.CurrentTriangleIndexNumberDebugFlagOn)
   {
      debugObject.Add("\nGET CURRENT TRIANGLE INDEX NUMBER\n");
      for(int triangleIndex=0;triangleIndex<=5;triangleIndex++)
      {
         debugObject.Add(StringConcatenate(" Triangle Breakout: ",triangleIndex," Price1: ",tboo[triangleIndex].Price1," Price2: ",tboo[triangleIndex].Price2," Price3: ",tboo[triangleIndex].Price3," DateTime1: ",TimeToStr(tboo[triangleIndex].DateTime1)," DateTime2: ",TimeToStr(tboo[triangleIndex].DateTime2)," DateTime3: ",TimeToStr(tboo[triangleIndex].DateTime3)," Bar 1: " + tboo[triangleIndex].Bar1, " Bar 2: " + tboo[triangleIndex].Bar2, " Bar 3: " + tboo[triangleIndex].Bar3, " Direction: ",tboo[triangleIndex].TriangleDirection,"\n"));   
      }
      debugObject.Add(" Frist Triangle Index: " + IntegerToString(indexNumber) + "\n");
   }  

   return indexNumber;
}


void UpdateTriangleBreakoutDirection()
{
   int currentTriangleIndexNumber = GetCurrentTriangleIndexNumber();
   
   if(currentTriangleIndexNumber != -1)
   {
      ctbod.TriangleDirection = tboo[currentTriangleIndexNumber].TriangleDirection;
   }

   if(ctbod.CurrentTriangleBreakoutDirectionFlagOn)
   {
      debugObject.Add("Triangle Breakout Direction: "); 
      debugObject.Add("Triangle Direction: " + ctbod.TriangleDirection + "\n");
   }
}

double GetEMA(int timeFrame,int maPeriod,int shift)
{
   return(iMA(NULL,timeFrame,maPeriod,0,MODE_EMA,0,shift));
}

int GetTrendFromEMA()
{
   //0 = Consolidation, 1 = Long, -1 = Short
   int trend = directionByIntValue.NeutralIntValue;    
   bool trendLongFound = true;
   bool trendShortFound = true;
   
   //Header
   if(temamam.ThreeEMATrendDirectionDebugFlagOn)
   {
      debugObject.Add
      (
         "\nTHREE EMA TREND DIRECTION\n"
      );
   }    

   for(int shift=1;shift <=3;shift++)
   {
      double EMAShortest = GetEMA(temamam.ThreeEMATrendDirection_Timeframe,temamam.ThreeEMATrendDirection_Shortest,shift);
      double EMAMiddle = GetEMA(temamam.ThreeEMATrendDirection_Timeframe,temamam.ThreeEMATrendDirection_Middle,shift);
      double EMALongest = GetEMA(temamam.ThreeEMATrendDirection_Timeframe,temamam.ThreeEMATrendDirection_Longest,shift);

      //Testing for long
      if(EMAShortest > EMAMiddle)
      {
         if(EMAMiddle > EMALongest)
         {
            trendShortFound = false;
            trendLongFound = trendLongFound && true;
         }
         else
         {
            trendLongFound = false;
         }
      }
      else
      {
         trendLongFound = false;
      }
      
      //Testing for Short
      if(EMAShortest < EMAMiddle)
      {
         if(EMAMiddle < EMALongest)
         {
            trendLongFound = false;
            trendShortFound = trendShortFound && true;
         }
         else
         {
            trendShortFound = false;
         }
      }
      else
      {
         trendShortFound = false;
      }
      
      //Body
      if(temamam.ThreeEMATrendDirectionDebugFlagOn)
      {
         debugObject.Add
         (
            " Shift " + IntegerToString(shift) + " " + 
            " EMA[" + temamam.ThreeEMATrendDirection_Shortest + "]: " + EMAShortest + " " +
            " EMA[" + temamam.ThreeEMATrendDirection_Middle + "]: " + EMAMiddle + " " +
            " EMA[" + temamam.ThreeEMATrendDirection_Longest + "]: " + EMALongest + " " + 
            " Trend Long Found: " + trendLongFound +  
            " Trend Short Found: " + trendShortFound + "\n" 
         );
      }      
   }
   
   //Can't be both directions
   if(trendLongFound && trendShortFound)
   {
      trendLongFound=false;
      trendShortFound=false;
   }
   
   if(trendLongFound){trend=directionByIntValue.LongIntValue;}
   if(trendShortFound){trend=directionByIntValue.ShortIntValue;}
   
   //Footer
   if(temamam.ThreeEMATrendDirectionDebugFlagOn)
   {
      debugObject.Add
      (
         " Timeframe: " + IntegerToString(temamam.ThreeEMATrendDirection_Timeframe) + "\n" 
         " EMA Trend Found: " + trend + "\n"
      );
   }

   return(trend);      
}

bool GetCurrentOpenPastPreviousOpenFlag()
{
   bool flag = false;
   if(wboem.TriangleBreakoutDirection==directionByIntValue.LongIntValue)
   {
      if(iOpen(NULL,wbm.WaveBreakTimeframe,0) > iOpen(NULL,wbm.WaveBreakTimeframe,1))
      {
         flag=true;
      }
   }
   if(wboem.TriangleBreakoutDirection==directionByIntValue.ShortIntValue)
   {
      if(iOpen(NULL,wbm.WaveBreakTimeframe,0) < iOpen(NULL,wbm.WaveBreakTimeframe,1))
      {
         flag=true;
      }
   }
   
   if(CurrentOpenPastPreviousOpenFlagEnabled)
   {
      debugObject.Add
      (
         "\nCURRENT OPEN PAST PREVIOUS OPEN\n" + 
         " Triangle Breakout Direction: " + wboem.TriangleBreakoutDirection + "\n" +
         " Wave Break Timeframe: " + wbm.WaveBreakTimeframe + "\n" + 
         " Current Open: " + iOpen(NULL,wbm.WaveBreakTimeframe,0) + "\n" + 
         " Previous Open: " + iOpen(NULL,wbm.WaveBreakTimeframe,1) + "\n" + 
         " Flag Setting: " + flag + "\n"
      );
   
   }
   
   
   return flag;
}

bool GetCurrentCandleColorCorrectFlag()
{
   bool flag = false;
   if(wboem.TriangleBreakoutDirection==directionByIntValue.LongIntValue)
   {
      if(IsCandleGreen(0,wbm.WaveBreakTimeframe))
      {
         flag = true;
      }
   }
   if(wboem.TriangleBreakoutDirection==directionByIntValue.ShortIntValue)
   {
      if(IsCandleRed(0,wbm.WaveBreakTimeframe))
      {
         flag = true;
      }
   }
   
   if(wbm.CurrentCandleColorCorrectDebugFlagOn)
   {
      debugObject.Add("\nCURRENT CANDLE COLOR CORRECT FLAG\n");
      debugObject.Add(" Triangle Breakout Direction: " + wboem.TriangleBreakoutDirection + "\n");
      debugObject.Add(" Flag Set: " + flag + "\n\n");
   }
   
   
   return flag;
}

bool GetPreviousCandleColorCorrectFlag()
{
   bool flag = false;
   if(wboem.TriangleBreakoutDirection==directionByIntValue.LongIntValue)
   {
      if(IsCandleGreen(1,wbm.WaveBreakTimeframe))
      {
         flag = true;
      }
   }
   if(wboem.TriangleBreakoutDirection==directionByIntValue.ShortIntValue)
   {
      if(IsCandleRed(1,wbm.WaveBreakTimeframe))
      {
         flag = true;
      }
   }
   
   if(wbm.PreviousCandleColorCorrectDebugFlagOn)
   {
      debugObject.Add("\nPREVIOUS CANDLE COLOR CORRECT FLAG\n");
      debugObject.Add(" Triangle Breakout Direction: " + wboem.TriangleBreakoutDirection + "\n");
      debugObject.Add(" Flag Set: " + flag + "\n\n");
   }
   
   
   return flag;
}

bool GetTrianglePointOneNotViolatedFlag()
{
   int currentTriangeleIndexNumber = GetCurrentTriangleIndexNumber();

   bool flag=false;
   if(wboem.TriangleBreakoutDirection==directionByIntValue.LongIntValue)
   {
      if(GetLowestPrice(NULL,wbm.WaveBreakTimeframe,0,tboo[currentTriangeleIndexNumber].Bar1-1)>tboo[currentTriangeleIndexNumber].Price1)
      {
         flag=true;
      }
   }
   
   if(wboem.TriangleBreakoutDirection==directionByIntValue.ShortIntValue)
   {
      if(GetHighestPrice(NULL,wbm.WaveBreakTimeframe,0,tboo[currentTriangeleIndexNumber].Bar1-1)<tboo[currentTriangeleIndexNumber].Price1)
      {
         flag=true;
      }
   } 
   
   if(wbm.TrianglePointOneNotVioloatedDebugFlagOn)
   {
      debugObject.Add("\nTRIANGLE POINT ONE NOT VIOLATED FLAG\n");
      debugObject.Add(" Current Triangle Index Number: " + currentTriangeleIndexNumber + "\n");
      debugObject.Add(" Triangle Breakout Direction: " + wboem.TriangleBreakoutDirection + "\n");
      debugObject.Add(" Wave Break Timeframe: " + wbm.WaveBreakTimeframe + "\n");
      debugObject.Add(" Triangle Breakout Object Bar 1: " + IntegerToString(tboo[currentTriangeleIndexNumber].Bar1) + "\n");
      debugObject.Add(" Triangle Breakout Object Price 1: " + DoubleToString(tboo[currentTriangeleIndexNumber].Price1,5) + "\n");
      debugObject.Add(" Flag Set: " + flag + "\n\n");
   }
      
   return flag;

}

void UpdateWaveBreakOrderEntryManager()
{
   wboem.ThreeEMATrendDirection = temamam.ThreeEMATrendDirection;
   wboem.BreakoutPriceFlag = cbopm.BreakoutPriceFlag;
   wboem.TriangleBreakoutDirection = ctbod.TriangleDirection;
   wboem.CurrentOpenPastPreviousOpenFlag=GetCurrentOpenPastPreviousOpenFlag();
   wboem.PreviousCandleColorCorrectFlag=GetPreviousCandleColorCorrectFlag();
   wboem.CurrentCandleColorCorrectFlag=GetCurrentCandleColorCorrectFlag();
   wboem.TrianglePointOneNotViolatedFlag=GetTrianglePointOneNotViolatedFlag();
   wboem.PivotLineType = ppo[0].PivotType;
   
   wboem.TradeDirection=directionByIntValue.NeutralIntValue;
   wboem.OkayToEnterTrade=false;
   
   bool longTradeFlag = true;
   bool shortTradeFlag = true;
      
   //Okay to go long?
   if(ThreeEMATrendDirectionEnabled){longTradeFlag = longTradeFlag && (wboem.ThreeEMATrendDirection == directionByIntValue.LongIntValue);}
   if(PivotLineTypeEnabled){longTradeFlag = longTradeFlag && (wboem.PivotLineType==directionByIntValue.LongIntValue);}
   if(BreakoutPriceFlagEnabled){longTradeFlag = longTradeFlag && wboem.BreakoutPriceFlag && (wboem.TriangleBreakoutDirection == directionByIntValue.LongIntValue);}
   if(TriangleBreakoutDirectionEnabled){longTradeFlag = longTradeFlag && (wboem.TriangleBreakoutDirection == directionByIntValue.LongIntValue);}
   if(CurrentCandleColorCorrectFlagEnabled){longTradeFlag = longTradeFlag && (wboem.CurrentCandleColorCorrectFlag);}
   if(PreviousCandleColorCorrectFlagEnabled){longTradeFlag = longTradeFlag && (wboem.PreviousCandleColorCorrectFlag);}
   if(CurrentOpenPastPreviousOpenFlagEnabled){longTradeFlag = longTradeFlag && (wboem.CurrentOpenPastPreviousOpenFlag);}
   if(TrianglePointOneNotVioloatedFlagEnabled){longTradeFlag = longTradeFlag && wboem.TrianglePointOneNotViolatedFlag;}
   
   //Okay to go short?
   if(ThreeEMATrendDirectionEnabled){shortTradeFlag = shortTradeFlag && (wboem.ThreeEMATrendDirection == directionByIntValue.ShortIntValue);}
   if(PivotLineTypeEnabled){shortTradeFlag = shortTradeFlag && (wboem.PivotLineType==directionByIntValue.ShortIntValue);}
   if(BreakoutPriceFlagEnabled){shortTradeFlag = shortTradeFlag && wboem.BreakoutPriceFlag && (wboem.TriangleBreakoutDirection == directionByIntValue.ShortIntValue);}
   if(TriangleBreakoutDirectionEnabled){shortTradeFlag = shortTradeFlag && (wboem.TriangleBreakoutDirection == directionByIntValue.ShortIntValue);}
   if(CurrentCandleColorCorrectFlagEnabled){shortTradeFlag = shortTradeFlag && (wboem.CurrentCandleColorCorrectFlag);}
   if(PreviousCandleColorCorrectFlagEnabled){shortTradeFlag = shortTradeFlag && (wboem.PreviousCandleColorCorrectFlag);}
   if(CurrentOpenPastPreviousOpenFlagEnabled){shortTradeFlag = shortTradeFlag && (wboem.CurrentOpenPastPreviousOpenFlag);}
   if(TrianglePointOneNotVioloatedFlagEnabled){shortTradeFlag = shortTradeFlag && wboem.TrianglePointOneNotViolatedFlag;}

   //Safety net.. can't be both directions so let's test this condition and set accordingly.
   if(longTradeFlag && shortTradeFlag)
   {
      longTradeFlag=false;
      shortTradeFlag=false;
      wboem.TradeDirection=directionByIntValue.NeutralIntValue;
      wboem.OkayToEnterTrade=false;      
   }
   
   if(longTradeFlag)
   {
      wboem.TradeDirection=directionByIntValue.LongIntValue;
      wboem.OkayToEnterTrade=true;
   }
   
   if(shortTradeFlag)
   {
      wboem.TradeDirection=directionByIntValue.ShortIntValue;
      wboem.OkayToEnterTrade=true;
   
   }     
   

   if(wboem.WaveBreakOrderEntryManagerFlagOn)
   {
      debugObject.Add("Wave Break Order Entry Manager\n");
      debugObject.Add("\n");
      
      debugObject.Add("ROBOT CONTROLLER\n");
      if(ThreeEMATrendDirectionEnabled){debugObject.Add(" Three EMA Trend Direction Enabled: " + ThreeEMATrendDirectionEnabled + "\n");}
      if(BreakoutPriceFlagEnabled){debugObject.Add(" Breakout Price Flag Enabled: " + BreakoutPriceFlagEnabled + "\n");}
      if(TriangleBreakoutDirectionEnabled){debugObject.Add(" Triangle Breakout Direction Enabled: " + TriangleBreakoutDirectionEnabled + "\n");}
      if(CurrentOpenPastPreviousOpenFlagEnabled){debugObject.Add(" Current Open Past Previous Open Flag Enabled: " + CurrentOpenPastPreviousOpenFlagEnabled + "\n");}
      if(CurrentCandleColorCorrectFlagEnabled){debugObject.Add(" Current Candle Color Correct Flag Enabled: " + CurrentCandleColorCorrectFlagEnabled + "\n");}
      if(PreviousCandleColorCorrectFlagEnabled){debugObject.Add(" Previous Candle Color Correct Flag Enabled: " + PreviousCandleColorCorrectFlagEnabled + "\n");}
      if(TrianglePointOneNotVioloatedFlagEnabled){debugObject.Add(" Triangle Point One Not Violoated Flag On Enabled: " + TrianglePointOneNotVioloatedFlagEnabled + "\n");}
      if(PivotLineTypeEnabled){debugObject.Add(" Pivot Line Type Enabled: " + PivotLineTypeEnabled + "\n");}
      debugObject.Add("\n");
      
      debugObject.Add("WAVEBREAK TRIGGERS\n");
      if(ThreeEMATrendDirectionEnabled){debugObject.Add(" Three EMA Trend: " + wboem.ThreeEMATrendDirection + "\n");}
      if(BreakoutPriceFlagEnabled){debugObject.Add(" Breakout Price Flag: " + wboem.BreakoutPriceFlag + "\n");}
      if(TriangleBreakoutDirectionEnabled){debugObject.Add(" Triangle Breakout Direction: " + wboem.TriangleBreakoutDirection + "\n");}
      if(PivotLineTypeEnabled){debugObject.Add(" Pivot Line Type: " + wboem.PivotLineType + "\n");}
      if(CurrentOpenPastPreviousOpenFlagEnabled){debugObject.Add(" Current Open Past Previous Open Flag: " + wboem.CurrentOpenPastPreviousOpenFlag + "\n");}
      if(CurrentCandleColorCorrectFlagEnabled){debugObject.Add(" Current Candle Color Correct Flag: " + wboem.CurrentCandleColorCorrectFlag + "\n");}
      if(PreviousCandleColorCorrectFlagEnabled){debugObject.Add(" Previous Candle Color Correct Flag: " + wboem.PreviousCandleColorCorrectFlag + "\n");}
      if(TrianglePointOneNotVioloatedFlagEnabled){debugObject.Add(" Triangle Point One Not Violated Flag On: " + wboem.TrianglePointOneNotViolatedFlag + "\n");}
      
      debugObject.Add(" Trade Direction: " + wboem.TradeDirection + "\n");
      debugObject.Add(" Okay To Enter Trade: " + wboem.OkayToEnterTrade + "\n");
   }
}

int GetOrderEntryDirection()
{
   int orderEntryDirection = directionByIntValue.NeutralIntValue;
   if(wboem.OkayToEnterTrade && wboem.TradeDirection == directionByIntValue.LongIntValue)
   {
      orderEntryDirection = directionByIntValue.LongIntValue;
   }

   if(wboem.OkayToEnterTrade && wboem.TradeDirection == directionByIntValue.ShortIntValue)
   {
      orderEntryDirection = directionByIntValue.ShortIntValue;
   }

   return orderEntryDirection;
}

double GetHighestPrice(string symbol, int timeframe, int startBar,int endBar) 
{
   double maxnum = -1000000;
   double val;
   int holdBar;
   
   if(startBar > endBar)
   {
      holdBar=endBar;
      endBar=startBar;
      startBar=holdBar;
   }

   for(int i=startBar; i<=endBar; i++) 
   {
      if(symbol == "NULL") {
         val = iHigh(NULL, timeframe, i);
      } else {
         val = iHigh(symbol, timeframe, i);
      }

      if(val > maxnum) {
         maxnum = val;
      }
   }

   return(maxnum);
}

double GetHighestPriceBar(string symbol, int timeframe, int startBar,int endBar) 
{
   double maxnum = -1000000;
   double val;
   int holdBar;
   int priceBar=0;
   
   if(startBar > endBar)
   {
      holdBar=endBar;
      endBar=startBar;
      startBar=holdBar;
   }

   for(int i=startBar; i<=endBar; i++) 
   {
      if(symbol == "NULL") {
         val = iHigh(NULL, timeframe, i);
      } else {
         val = iHigh(symbol, timeframe, i);
      }

      if(val > maxnum) {
         maxnum = val;
         priceBar = i;
      }
   }

   return(priceBar);
}


double GetLowestPriceBar(string symbol, int timeframe, int startBar, int endBar) {
   double minnum = 1000000;
   double val;
   int holdBar;
   int priceBar=0;
   
   if(startBar > endBar)
   {
      holdBar=endBar;
      endBar=startBar;
      startBar=holdBar;
   } 

   for(int i=startBar; i<=endBar; i++) {
      if(symbol == "NULL")
      {
         val = iLow(NULL, timeframe, i);
      } else {
         val = iLow(symbol, timeframe, i);
      }
      if(val < minnum) {
         minnum = val;
         priceBar = i;
      }
   }

   return(priceBar);
}

double GetLowestPrice(string symbol, int timeframe, int startBar, int endBar) {
   double minnum = 1000000;
   double val;
   int holdBar;
   
   if(startBar > endBar)
   {
      holdBar=endBar;
      endBar=startBar;
      startBar=holdBar;
   } 

   for(int i=startBar; i<=endBar; i++) {
      if(symbol == "NULL")
      {
         val = iLow(NULL, timeframe, i);
      } else {
         val = iLow(symbol, timeframe, i);
      }
      if(val < minnum) {
         minnum = val;
      }
   }

   return(minnum);
}

void ProcessWaveBreak(string symbol,int timeframe)
{
   //Clean chart if we are running this for first time.
   if(!wbm.InitializedWaveBreakFlagOn)
   {
      DeleteAllObjectsByPrefix("PTT");
      wbm.InitializedWaveBreakFlagOn=true;   
   }
   
   //Variable initializations
   int currentBar = 1;
   int lastClusterType = 0;
   int ppoIndex = 0;
   string objectName;
   long lineColor;

   //Populate object with trigger clusters that we find
   for(int clusterIndex=0;clusterIndex<=wbm.WaveBreakPivotPointsToTrack;clusterIndex++)
   {
      //Find Green or Red bar cluster
      for(int x=currentBar;x<Bars-4;x++)
      {
            if(lastClusterType !=directionByIntValue.LongIntValue)
            {
               if(GetXCandlesGreenFlagCount(x,x+2,wbm.WaveBreakTimeframe)==3)
               {
                  wpco[clusterIndex].BarStart = x;
                  wpco[clusterIndex].BarEnd = x+2;
                  wpco[clusterIndex].ClusterType = directionByIntValue.LongIntValue;
                  
                  if(clusterIndex>0)
                  {
                     ppo[ppoIndex].PivotBar = GetHighestPriceBar(NULL,wbm.WaveBreakTimeframe,wpco[clusterIndex-1].BarStart,wpco[clusterIndex].BarEnd);
                     ppo[ppoIndex].PivotPrice = iHigh(NULL,wbm.WaveBreakTimeframe,ppo[ppoIndex].PivotBar);
                     ppo[ppoIndex].PivotType = directionByIntValue.LongIntValue;
                     ppo[ppoIndex].PivotDate = iTime(NULL,wbm.WaveBreakTimeframe,ppo[ppoIndex].PivotBar);
                  }
                  
                  if(ppoIndex==1)
                  {
                     ppo[0].PivotBar = GetLowestPriceBar(NULL,wbm.WaveBreakTimeframe,1,ppo[ppoIndex].PivotBar);
                     ppo[0].PivotPrice = iLow(NULL,wbm.WaveBreakTimeframe,ppo[0].PivotBar);
                     ppo[0].PivotType = directionByIntValue.ShortIntValue;
                     ppo[0].PivotDate = iTime(NULL,wbm.WaveBreakTimeframe,ppo[0].PivotBar);
                  }

                  if(ppoIndex>0)
                  {
                     CreateShortArrow(symbol,timeframe,"PTT_ARROW_" + ppoIndex, ppo[ppoIndex].PivotBar);
                  }

                  objectName = "PRT_WAVE_LINE_" + ppoIndex;
                  lineColor = Red;
                  
                  if(ppoIndex>0)
                  {
                     DrawTrendLine
                     (
                        NULL,
                        wbm.WaveBreakTimeframe,
                        ppo[ppoIndex].PivotBar,
                        ppo[ppoIndex-1].PivotBar,
                        ppo[ppoIndex].PivotPrice,
                        ppo[ppoIndex-1].PivotPrice,
                        objectName,
                        lineColor,
                        STYLE_SOLID,
                        3,OBJ_TREND
                     );
                  }                     
                  
                  ppoIndex++;
                  
                  currentBar=x+3;
                  lastClusterType = directionByIntValue.LongIntValue;
                  break;
               }
            }
            
            if(lastClusterType !=directionByIntValue.ShortIntValue)
            {
               if(GetXCandlesRedFlagCount(x,x+2,wbm.WaveBreakTimeframe)==3)
               {
                  wpco[clusterIndex].BarStart = x;
                  wpco[clusterIndex].BarEnd = x+2;
                  wpco[clusterIndex].ClusterType = directionByIntValue.ShortIntValue;
                  
                  if(clusterIndex>0)
                  {
                     ppo[ppoIndex].PivotBar = GetLowestPriceBar(NULL,wbm.WaveBreakTimeframe,wpco[clusterIndex-1].BarStart,wpco[clusterIndex].BarEnd);
                     ppo[ppoIndex].PivotPrice = iLow(NULL,wbm.WaveBreakTimeframe,ppo[ppoIndex].PivotBar);
                     ppo[ppoIndex].PivotType = directionByIntValue.ShortIntValue;
                     ppo[ppoIndex].PivotDate = iTime(NULL,wbm.WaveBreakTimeframe,ppo[ppoIndex].PivotBar);
                  }
                  
                  if(ppoIndex==1)
                  {
                     ppo[0].PivotBar = GetHighestPriceBar(NULL,wbm.WaveBreakTimeframe,1,ppo[ppoIndex].PivotBar);
                     ppo[0].PivotPrice = iHigh(NULL,wbm.WaveBreakTimeframe,ppo[0].PivotBar);
                     ppo[0].PivotType = directionByIntValue.LongIntValue;
                     ppo[0].PivotDate = iTime(NULL,wbm.WaveBreakTimeframe,ppo[0].PivotBar);
                  }

                  if(ppoIndex>0)
                  {
                     CreateLongArrow(symbol,timeframe,"PTT_ARROW_" + ppoIndex, ppo[ppoIndex].PivotBar);
                  }

                  objectName = "PRT_WAVE_LINE_" + ppoIndex;
                  lineColor = Green;
                  
                  if(ppoIndex>0)
                  {
                     DrawTrendLine
                     (
                        NULL,
                        wbm.WaveBreakTimeframe,
                        ppo[ppoIndex].PivotBar,
                        ppo[ppoIndex-1].PivotBar,
                        ppo[ppoIndex].PivotPrice,
                        ppo[ppoIndex-1].PivotPrice,
                        objectName,
                        lineColor,
                        STYLE_SOLID,
                        3,OBJ_TREND
                     ); 
                  }

                  ppoIndex++;

                  currentBar=x+3;
                  lastClusterType = directionByIntValue.ShortIntValue;
                  break;
               }
            }
       } 
       
       if(wbm.ClusterObjectDebugFlagOn)
       {
          debugObject.Add(StringConcatenate("Cluster Object Nomber: ",clusterIndex," Start: ",wpco[clusterIndex].BarStart, " End: ",wpco[clusterIndex].BarEnd," ClusterType: ",wpco[clusterIndex].ClusterType,"\n"));
       }           
   }
   
   if(wbm.PivotBarDebugFlagOn)
   {      
      for(int j=0;j<=ppoIndex-1;j++)
      {          
         debugObject.Add(StringConcatenate("Pivot Bar ",j," is at bar " ,ppo[j].PivotBar," with Pivot Type of ",ppo[j].PivotType," and Price ",ppo[j].PivotPrice," at Date ", TimeToStr(ppo[j].PivotDate),"\n"));
      }
   }

}

void DrawTrendLine(string symbol,int timeFrame,int startBar,int endBar,double price1,double price2,string objectName,long lineColor,int objectStyle,int objectWidth,ENUM_OBJECT objectType)
{
   long chartID = symbol;
   //ENUM_OBJECT objectType = OBJ_TREND;
   int subWindow = 0;
   datetime time1;
   datetime time2;
   
   //objectStyle
   // STYLE_SOLID
   // STYLE_DASH
   // STYLE_DOT
   // STYLE_DASHDOT
   // STYLE_DASHDOTDOT
   
   time1 = iTime(symbol,timeFrame,startBar);
   time2 = iTime(symbol,timeFrame,endBar);;
 
   if(ObjectFind(chartID,objectName) == -1)
   {
      ObjectCreate(chartID,objectName,objectType,subWindow,time1,price1,time2,price2);
      ObjectSet(objectName,OBJPROP_RAY,False);
      ObjectSet(objectName,OBJPROP_COLOR,lineColor);
      ObjectSet(objectName,OBJPROP_TIMEFRAMES,OBJ_ALL_PERIODS);
      ObjectSet(objectName,OBJPROP_WIDTH,objectWidth);
      ObjectSet(objectName,OBJPROP_STYLE,objectStyle);
      ChartRedraw(0);
   }
   else
   {
      ObjectMove(chartID,objectName,0,time1,price1);
      ObjectMove(chartID,objectName,1,time2,price2);
      ObjectSet(objectName,OBJPROP_COLOR,lineColor);
      ObjectSet(objectName,OBJPROP_TIMEFRAMES,OBJ_ALL_PERIODS);
      ObjectSet(objectName,OBJPROP_WIDTH,objectWidth);
      ObjectSet(objectName,OBJPROP_STYLE,objectStyle);
      ChartRedraw(0);
   }
}

//Points are set from right to left as 1,2, and 3. When in this order, we can determine, up trend, down trend, or indeterminate.
int GetTriangleDirection(double price1,double price2,double price3)
{
   int trend = 0;
   
   //Down Triangle
   if(price1 < price3 && price1 > price2 && price2 < price1 && price2 < price3 && price3 > price1 && price3 > price2)
   {  
      trend = -1;
   }
   
   //Up Triangle
   if(price1 > price3 && price1 < price2 && price2 > price1 && price2 > price3 && price3 < price1 && price3 < price2)
   {
      trend = 1;
   }
   return trend;
}

void CreateBreakoutTriangles(string symbol,int timeFrame,int startPivotIndex,int endPivotIndex)
{
   long chartID = symbol;
   ENUM_OBJECT objectType = OBJ_TRIANGLE;
   int subWindow = 0;
   long lineColor = Yellow;
   int objectWidth = 1;
   int objectStyle = STYLE_SOLID;
   string objectName;
   
   datetime time1;
   double price1;
   datetime time2;
   double price2;
   datetime time3;
   double price3;
   
   int triangleIndex=0;
   
   int trend;
   
   //objectStyle
   // STYLE_SOLID
   // STYLE_DASH
   // STYLE_DOT
   // STYLE_DASHDOT
   // STYLE_DASHDOTDOT
   
   for(int tIndex = 1;tIndex<=endPivotIndex-2;tIndex++)
   {
      trend = directionByIntValue.NeutralIntValue;

      time1 = ppo[tIndex].PivotDate;
      price1 = ppo[tIndex].PivotPrice;

      time2 = ppo[tIndex+1].PivotDate;
      price2 = ppo[tIndex+1].PivotPrice;

      time3 = ppo[tIndex+2].PivotDate;
      price3 = ppo[tIndex+2].PivotPrice;
      
      trend = GetTriangleDirection(price1,price2,price3);
      
      //Save Triangle data
      if(trend != directionByIntValue.NeutralIntValue)
      {
         tboo[triangleIndex].DateTime1=time1;
         tboo[triangleIndex].DateTime2=time2;
         tboo[triangleIndex].DateTime3=time3;
         tboo[triangleIndex].Price1=price1;
         tboo[triangleIndex].Price2=price2;
         tboo[triangleIndex].Price3=price3;   
         tboo[triangleIndex].Bar1=iBarShift(NULL,timeFrame,time1);
         tboo[triangleIndex].Bar2=iBarShift(NULL,timeFrame,time2);
         tboo[triangleIndex].Bar3=iBarShift(NULL,timeFrame,time3);
         tboo[triangleIndex].TriangleDirection=trend;
         
         //Save breakout line data
         if(trend==directionByIntValue.LongIntValue)
         {
            bolo[triangleIndex].BreakoutLineTrend = directionByIntValue.LongIntValue;
            UpdateLongBreakoutLineProperties(symbol,timeFrame,ppo[tIndex+1].PivotBar,ppo[tIndex].PivotBar,triangleIndex); 
         }
         else
         {
            bolo[triangleIndex].BreakoutLineTrend = directionByIntValue.ShortIntValue;
            UpdateShortBreakoutLineProperties(symbol,timeFrame,ppo[tIndex+1].PivotBar,ppo[tIndex].PivotBar,triangleIndex); 
         }

         if(wbm.BreakoutLineDebugFlagOn)
         {
            debugObject.Add("Breakout Line: (x1,y1): ("+bolo[triangleIndex].x1+","+bolo[triangleIndex].y1+") (x2,y2): ("+bolo[triangleIndex].x2+","+bolo[triangleIndex].y2+") (x3,y3): ("+bolo[triangleIndex].x3+","+bolo[triangleIndex].y3+") slope: "+bolo[triangleIndex].m+" b: "+bolo[triangleIndex].b+" y=mx+b: y="+bolo[triangleIndex].m+"x+"+bolo[triangleIndex].b + " Destination Bar: " + bolo[triangleIndex].x2 + "\n");   
         }  

         //Save Debug Info
         if(wbm.TriangleBreakoutDebugFlagOn)
         {
            debugObject.Add(StringConcatenate("Triangle Breakout: ",triangleIndex," Price1: ",tboo[triangleIndex].Price1," Price2: ",tboo[triangleIndex].Price2," Price3: ",tboo[triangleIndex].Price3," DateTime1: ",TimeToStr(tboo[triangleIndex].DateTime1)," DateTime2: ",TimeToStr(tboo[triangleIndex].DateTime2)," DateTime3: ",TimeToStr(tboo[triangleIndex].DateTime3)," Bar 1: " + tboo[triangleIndex].Bar1, " Bar 2: " + tboo[triangleIndex].Bar2, " Bar 3: " + tboo[triangleIndex].Bar3, " Direction: ",tboo[triangleIndex].TriangleDirection,"\n"));   
         }         
         
         
         //Draw Breakout Line Object
         if(bolo[triangleIndex].BreakoutLineTrend == directionByIntValue.LongIntValue){lineColor = Green;}
         if(bolo[triangleIndex].BreakoutLineTrend == directionByIntValue.ShortIntValue){lineColor = Red;}
         
         objectName = StringConcatenate("PRT_BREAKOUTLINE_",time2);
         objectType = OBJ_TREND;
         int x1 = bolo[triangleIndex].x1;
         double y1 = bolo[triangleIndex].y1;
         int x2 = bolo[triangleIndex].x2;
         double y2 = bolo[triangleIndex].y2;
         int x3 = bolo[triangleIndex].x3;
         double y3 = bolo[triangleIndex].y3;
         double m = bolo[triangleIndex].m;
         double b = bolo[triangleIndex].b;
         
         //VerboseLog("Draw Breakout Line - (x1,y1): ("+x1+","+y1+") (x2,y2): ("+x2+","+y2+") (x3,y3): ("+x3+","+y3+") slope: "+m+" b: "+b+" y=mx+b: y="+m+"x+"+b + " Destination Bar: " + x2 + " x3: " + x3 + " y3: " + y3);
         
         if(ObjectFind(chartID,objectName) == -1)
         {
            ObjectCreate(chartID,objectName,objectType,subWindow,iTime(symbol,timeFrame,x1),y1,iTime(symbol,timeFrame,x3),y3);
            ObjectSet(objectName,OBJPROP_COLOR,lineColor);
            ObjectSet(objectName,OBJPROP_TIMEFRAMES,OBJ_ALL_PERIODS);
            ObjectSet(objectName,OBJPROP_WIDTH,objectWidth);
            ObjectSet(objectName,OBJPROP_STYLE,objectStyle);
            ObjectSet(objectName,OBJPROP_RAY,false);
            ChartRedraw(0);
         }
         else
         {
            ObjectMove(chartID,objectName,0,iTime(symbol,timeFrame,x1),y1);
            ObjectMove(chartID,objectName,1,iTime(symbol,timeFrame,x3),y3);
            ObjectSet(objectName,OBJPROP_COLOR,lineColor);
            ObjectSet(objectName,OBJPROP_TIMEFRAMES,OBJ_ALL_PERIODS);
            ObjectSet(objectName,OBJPROP_WIDTH,objectWidth);
            ObjectSet(objectName,OBJPROP_STYLE,objectStyle);
            ObjectSet(objectName,OBJPROP_RAY,false);
            ChartRedraw(0);
         }
      }
      else
      {
         //Clear data for triangle not showing data. Most important piece here is setting Direction to Neutral
         tboo[triangleIndex].DateTime1=0;
         tboo[triangleIndex].DateTime2=0;
         tboo[triangleIndex].DateTime3=0;
         tboo[triangleIndex].Price1=0;
         tboo[triangleIndex].Price2=0;
         tboo[triangleIndex].Price3=0;   
         tboo[triangleIndex].Bar1=0;
         tboo[triangleIndex].Bar2=0;
         tboo[triangleIndex].Bar3=0;
         tboo[triangleIndex].TriangleDirection=directionByIntValue.NeutralIntValue;
      }
      
      //Draw Triangle Object
      lineColor = LightYellow;
      if(trend == directionByIntValue.LongIntValue){lineColor = PaleGreen;}
      if(trend == directionByIntValue.ShortIntValue){lineColor = Pink;}
            
      objectName = StringConcatenate("PRT_TRIANGLE_",tIndex);
      objectType = OBJ_TRIANGLE;      
      if(ObjectFind(chartID,objectName) == -1)
      {
         ObjectCreate(chartID,objectName,objectType,subWindow,time1,price1,time2,price2,time3,price3);
         ObjectSet(objectName,OBJPROP_COLOR,lineColor);
         ObjectSet(objectName,OBJPROP_TIMEFRAMES,OBJ_ALL_PERIODS);
         ObjectSet(objectName,OBJPROP_WIDTH,objectWidth);
         ObjectSet(objectName,OBJPROP_STYLE,objectStyle);
         ChartRedraw(0);
      }
      else
      {
         ObjectMove(chartID,objectName,0,time1,price1);
         ObjectMove(chartID,objectName,1,time2,price2);
         ObjectMove(chartID,objectName,2,time3,price3);
         ObjectSet(objectName,OBJPROP_COLOR,lineColor);
         ObjectSet(objectName,OBJPROP_TIMEFRAMES,OBJ_ALL_PERIODS);
         ObjectSet(objectName,OBJPROP_WIDTH,objectWidth);
         ObjectSet(objectName,OBJPROP_STYLE,objectStyle);
         ChartRedraw(0);
      }
      

   //}
      triangleIndex++;
            
   }
   
   
}

void UpdateCurrentBreakoutPriceFlagManager()
{
   //y=mx+b;
   bool breakoutFlag = false;
   double m=bolo[0].m;
   double y;
   int x = 1;
   double b = bolo[0].b;
   double lastOpenPrice;      
   double breakoutPrice;
   int timeframe = wbm.WaveBreakTimeframe;
   
   y=m*x+b;      
   breakoutPrice = y;
   lastOpenPrice = iOpen(NULL,timeframe,x);
         
   if(bolo[0].BreakoutLineTrend==directionByIntValue.LongIntValue)
   {
      if(lastOpenPrice > breakoutPrice){breakoutFlag=true;}
   }
      
   if(bolo[0].BreakoutLineTrend==directionByIntValue.ShortIntValue)
   {
      if(lastOpenPrice < breakoutPrice){breakoutFlag=true;} 
   }

   if(wbm.BreakoutLinePriceDebugFlagOn)
   {
      debugObject.Add("Breakout Price Flag: " + breakoutPrice + " ");
      debugObject.Add("Last Open Price: "+ lastOpenPrice + " " );
      debugObject.Add("Breakout Flag: " + breakoutFlag + "\n");
   }
   
   cbopm.CurrentBreakoutLastOpenPrice = lastOpenPrice;
   cbopm.CurrentBreakoutLastOpenPrice=lastOpenPrice;
   cbopm.BreakoutPriceFlag=breakoutFlag;
}

void UpdateLongBreakoutLineProperties(string symbol,int timeFrame,int startBar,int endBar,int triangleIndex)
{
   //Define first point
   int x1 = startBar;
   double y1 = iHigh(symbol,timeFrame,startBar);
   bolo[triangleIndex].m = 999;
   
   //VerboseLog("(x1,y1): (",x1,",",y1,")");
   
   for(int bar = startBar-1;bar>=endBar;bar--)
   {
      //Define second point
      int x2 = bar;
      double y2 = GetHighestPriceOfOpenClose(symbol,timeFrame,bar);
      
      //Define slope by m=(y2-y1)/(x2-x1)
      double m = (y2-y1)/(x2-x1);
      
      //y-Intercept
      double b = y2-m*x2;
      
      //Final Point Coords-Calculate x3 from formula x3=(y3-b)/m
      int x3 = endBar - 10;
      if(x3<0){x3=0;}
      double y3=m*x3+b;
      
      if(m<bolo[triangleIndex].m)
      {
         //Store all pieces for origin point and destination point along with slope and y-intercept so we can use the formula y=mx+b to find the price when given any bar number
         bolo[triangleIndex].m = m;
         bolo[triangleIndex].x1 = x1;
         bolo[triangleIndex].y1 = y1;
         bolo[triangleIndex].x2 = x2;
         bolo[triangleIndex].y2 = y2;
         bolo[triangleIndex].x3=x3;
         bolo[triangleIndex].y3=y3;
         bolo[triangleIndex].b = b;
      }

      //VerboseLog("(x1,y1): ("+x1+","+y1+") (x2,y2): ("+x2+","+y2+") slope: "+m+" b: "+b+" y=mx+b: y="+m+"x+"+b + " Destination Bar: " +  bolo[triangleIndex].x2 + " x3: " + x3 + " y3: " + y3);
   }
}

void UpdateShortBreakoutLineProperties(string symbol,int timeFrame,int startBar,int endBar,int triangleIndex)
{
   //Define first point
   int x1 = startBar;
   double y1 = iLow(symbol,timeFrame,startBar);
   bolo[triangleIndex].m = -999;
   
   //VerboseLog("(x1,y1): (",x1,",",y1,")");
   
   for(int bar = startBar-1;bar>=endBar;bar--)
   {
      //Define second point
      int x2 = bar;
      double y2 = GetLowestPriceOfOpenClose(symbol,timeFrame,bar);
      
      //Define slope by m=(y2-y1)/(x2-x1)
      double m = (y2-y1)/(x2-x1);
      
      //y-Intercept
      double b = y2-m*x2;
      
      //Final Point Coords-Calculate x3 from formula x3=(y3-b)/m
      int x3 = endBar - 10;
      if(x3<0){x3=0;}
      double y3=m*x3+b;
      

      if(m>bolo[triangleIndex].m)
      {
         //Store all pieces for origin point and destination point along with slope and y-intercept so we can use the formula y=mx+b to find the price when given any bar number
         bolo[triangleIndex].m = m;
         bolo[triangleIndex].x1 = x1;
         bolo[triangleIndex].y1 = y1;
         bolo[triangleIndex].x2 = x2;
         bolo[triangleIndex].y2 = y2;
         bolo[triangleIndex].x3 = x3;
         bolo[triangleIndex].y3 = y3;
         bolo[triangleIndex].b = b;
      }

      //VerboseLog("(x1,y1): ("+x1+","+y1+") (x2,y2): ("+x2+","+y2+") slope: "+m+" b: "+b+" y=mx+b: y="+m+"x+"+b + " Destination Bar: " +  bolo[triangleIndex].x2 + " x3: " + x3 + " y3: " + y3);
   }
}

double GetHighestPriceOfOpenClose(string symbol,int timeFrame,int bar)
{
   double openPrice = iOpen(symbol,timeFrame,bar);
   double closePrice = iClose(symbol,timeFrame,bar);
   double price = closePrice;

   if(openPrice > closePrice)
   {
      price=openPrice;
   }

   return price;
}

double GetLowestPriceOfOpenClose(string symbol,int timeFrame,int bar)
{
   double openPrice = iOpen(symbol,timeFrame,bar);
   double closePrice = iClose(symbol,timeFrame,bar);
   double price = closePrice;

   if(openPrice < closePrice)
   {
      price=openPrice;
   }

   return price;
}

void DeleteAllObjectsByPrefix(string prefix)
{
   string cmd;

   for(int x=ObjectsTotal()-1;x>=0;x--)
   {
      cmd = ObjectName(x);
      if(StringSubstr(ObjectName(x),0,StringLen(prefix)) == prefix)
      {
         ObjectDelete(cmd);
      }
   }
   WindowRedraw();
   Print("All Objects with Prefix " + prefix + " Cleared");
}

bool IsCandleRed(int bar,int timeFrame)
{
   bool isCandleRed = false;
   if(iOpen(NULL, timeFrame , bar) > iClose(NULL, timeFrame , bar))
   {
      isCandleRed = true;
   }
   return(isCandleRed);
}

bool IsCandleGreen(int bar,int timeFrame)
{
   bool isCandleGreen = false;
   if(iOpen(NULL, timeFrame , bar) < iClose(NULL, timeFrame , bar))
   {
      isCandleGreen = true;
   }
   return(isCandleGreen);
}

int GetXCandlesGreenFlagCount(int startBar, int endBar,int timeFrame)
{
   int result = 0;
   for (int bar = startBar; bar <= endBar; bar++)
   {
      if(IsCandleGreen(bar,timeFrame)==1)
      {
         result=result + 1;
      }
   }
   return(result);
}

int GetXCandlesRedFlagCount(int startBar, int endBar,int timeFrame)
{
   int result = 0;
   for (int bar = startBar; bar <= endBar; bar++)
   {
      if(IsCandleRed(bar,timeFrame)==1)
      {
         result=result + 1;
      }
   }
  return(result);   
}

bool CreateLongArrow(string symbol,int timeframe,string objectName,int barsBack)
{
   bool result = false;
   int time = iTime(symbol,timeframe,barsBack);
   double price = iLow(symbol,timeframe,barsBack)-80*Point;
   
   if(ObjectFind(0,objectName) !=0)
   {
      ObjectCreate(objectName, OBJ_ARROW, 0, time,price); //draw an up arrow
      ObjectSet(objectName, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSet(objectName, OBJPROP_ARROWCODE, SYMBOL_ARROWUP);
      ObjectSet(objectName, OBJPROP_COLOR, Green);  
   }
   else
   {
      ObjectMove(0,objectName,0,time,price);
   }
   
   return result;
}

bool CreateShortArrow(string symbol,int timeframe,string objectName,int barsBack)
{
   bool result = false;
   int time = iTime(symbol,timeframe,barsBack);
   double price = iHigh(symbol,timeframe,barsBack)+480*Point;
   
   if(ObjectFind(0,objectName) !=0)
   {
      ObjectCreate(objectName, OBJ_ARROW, 0, time,price); //draw an down arrow
      ObjectSet(objectName, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSet(objectName, OBJPROP_ARROWCODE, SYMBOL_ARROWDOWN);
      ObjectSet(objectName, OBJPROP_COLOR, Red);
   }
   else
   {
      ObjectMove(0,objectName,0,time,price);
   }   
   
   return result;
}

void MoveStopsOnAllOpenOrders(double stopPrice, bool moveStopOnlyWhenInProfit)
{
   int stopPriceCheck = 0;
   for (int cc = OrdersTotal() - 1; cc >= 0; cc--) 
   {
      if (!OrderSelect(cc, SELECT_BY_POS) ) continue;
      if (OrderStopLoss() == stopPrice) continue;      //NO sense modify order if order stop price matches proposed price
      if(OrderSymbol() == Symbol()) 
      {
         if(OrderType() == OP_BUY)
         {
            //For safety, make sure price is greater than stopPrice before trying to modify order
            if(Bid > stopPrice)
            {
               if(OrderStopLoss() < stopPrice)
               {
                  if(moveStopOnlyWhenInProfit == false)
                  {
                     stopPriceCheck = 1;
                  }
                  else
                  {
                     if(Bid > OrderOpenPrice())
                     {
                        stopPriceCheck = 1;
                     }
                  }
               }
            }
         }
         
         if(OrderType() == OP_SELL)
         {
            //For safety, make sure price is less than stopPrice before trying to modify order
            if(Ask < stopPrice)
            {
               if(OrderStopLoss() > stopPrice)
               {
                  if(moveStopOnlyWhenInProfit == false)
                  {
                     stopPriceCheck = 1;
                  }
                  else
                  {
                     if(Ask < OrderOpenPrice())
                     {
                        stopPriceCheck = 1;
                     }
                  }                  
               }
            }
         }
         
         //If No Stop Loss than we definitely want to make one.
         if(OrderStopLoss() == 0){stopPriceCheck = 1;}
         
         if(stopPriceCheck == 1)
         {
            Verbose("GBLMoveSLTo: Moving Ticket ",OrderTicket(), " with Open Price ",OrderOpenPrice()," stop loss from ",OrderStopLoss(), " to ",stopPrice);
            OrderModify(OrderTicket(), OrderOpenPrice(), stopPrice, OrderTakeProfit(), 0);
            
         }
      }
   }
}

void ProcessOpenOrder(int cmd)
{
   string comment;
   int magicNumber;
   string ruleName;
   double price;
   
   if(cmd=OP_BUY)
   {
      comment = "Long Entry";
      magicNumber = 1000;
      ruleName = "Okay To Go Long";
      price = Bid;
   }
   
   if(cmd=OP_SELL)
   {
      comment = "Short Entry";
      magicNumber = 2000;
      ruleName = "Okay To Go Short";
      price = Ask;
   }   

   sqOpenOrder(NULL,cmd,1,price,comment,magicNumber,ruleName);


   //Temporary Tight Trail Stop Control
   //double stopPrice;
   //if(wboem.TradeDirection==directionByIntValue.LongIntValue)
   //{
   //   stopPrice = GetLowestPriceOfOpenClose(NULL,wbm.WaveBreakTimeframe,3);
   //   MoveStopsOnAllOpenOrders(stopPrice,true);   
   //}
   
   //if(wboem.TradeDirection==directionByIntValue.ShortIntValue)
   //{
   //   stopPrice = GetHighestPriceOfOpenClose(NULL,wbm.WaveBreakTimeframe,3);
   //   MoveStopsOnAllOpenOrders(stopPrice,true);   
   //}
}

void CloseOrdersOnDirectionChange()
{
   bool closeAllFlag = false;
   int marketPosition = sqGetMarketPosition();
   
   if(marketPosition == directionByIntValue.LongIntValue && wboem.PivotLineType != directionByIntValue.LongIntValue)
   {
      closeAllFlag = true;
   }
   
   if(marketPosition == directionByIntValue.ShortIntValue && wboem.PivotLineType != directionByIntValue.ShortIntValue)
   {
      closeAllFlag = true;
   }

   if(closeAllFlag)
   {
      CloseAllOrdersOnCurrentPair();
   }
}

void CloseAllOrdersOnCurrentPair() {
   bool found = false;

   Verbose("Closing all orders for " + Symbol() + " ----------------");

   for(int i=OrdersTotal()-1; i>=0; i--) {
      found = true;

      if (OrderSelect(i,SELECT_BY_POS)==true) 
      {
         if(OrderSymbol() == Symbol())
         {
            if(OrderType() == OP_BUY || OrderType() == OP_SELL) 
            {
               sqClosePositionAtMarket(-1);
            } else 
            {
               Verbose("Deleting pending order");
               OrderDelete(OrderTicket());
            }
         }
      }
   }

   if(!found) {
      Verbose("No orders found for " + Symbol());
   }
   Verbose("Closing all orders on " + Symbol() + " finished ----------------");
}




//Object Instantiations
DebugObject debugObject;
WavePointClusterObject wpco[2000];
PivotPointObject ppo[2000];
TriangleBreakoutObject tboo[2000];
DirectionByIntValue directionByIntValue;
PivotTypes pivotType;
WaveBreakManager wbm; 
BreakoutLineObject bolo[2000];
WaveBreakOrderEntryManager wboem;
TripleEMAMovingAverageManager temamam;
CurrentBreakoutLinePriceManager cbopm;
CurrentTriangleBreakoutDirection ctbod;
